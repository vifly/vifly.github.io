<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>折腾 on Vifly 的博客</title><link>https://viflythink.com/tags/%E6%8A%98%E8%85%BE/</link><description>Recent content in 折腾 on Vifly 的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 08 Aug 2023 00:00:00 +0800</lastBuildDate><atom:link href="https://viflythink.com/tags/%E6%8A%98%E8%85%BE/atom.xml" rel="self" type="application/rss+xml"/><item><title>我的新 Arch</title><link>https://viflythink.com/New-Install-Arch/</link><pubDate>Tue, 08 Aug 2023 00:00:00 +0800</pubDate><guid>https://viflythink.com/New-Install-Arch/</guid><description>&lt;img src="https://viflythink.com/New-Install-Arch/show.jpg" alt="Featured image of post 我的新 Arch" />&lt;p>前段时间存储相关的元件价格大跳水，博主终于等到了这个时机给自己组装了一台期待已久的台式机。不得不说今年的 PC 组件价格十分魔幻，SSD 甚至能比 HDD 便宜，于是我的台式机只配备了 SSD，另外基于不打算给老黄送钱的心理，也暂时没配置独显，以上使得自己的组装工作避免了一大堆麻烦，不用给 HDD 接 SATA 线，也不用给独显接电源线，整个装机过程非常的轻松愉快。在电脑能开机后，接下来当然是给它装上熟悉的 Arch Linux 用来日常工作与娱乐。尽管在之前的&lt;a class="link" href="https://viflythink.com/Try_Arch_Linux/" target="_blank" rel="noopener"
>从 Debian 迁移到 Arch Linux&lt;/a> 一文已经说过了我是如何安装 Arch 的，然后还安利了一部分软件，但时过境迁，由于自己能力的进步与发现了更好的软件，这回也折腾了一些之前没试过的新玩意，所以本文既是新安装 Arch 的随手记录，也是对旧文的一个更新，推荐与上面的旧文对比阅读。&lt;/p>
&lt;h1 id="安装基本系统">安装基本系统
&lt;/h1>&lt;p>与之前相比，这次安装 Arch 就大胆地实验了一些没尝试过的新玩意。之前完全按教程配置双系统时使用了 GRUB 作为引导加载程序（boot loader），而由于这次不打算在电脑上安装 Windows，所以用 systemd-boot 取而代之。然后也使用了 Btrfs 作为我的新 Arch 的根文件系统（具体原因见下文），当然，还要加上 LUKS 全盘加密，为了方便硬盘解密，还要配置 &lt;a class="link" href="https://0pointer.net/blog/unlocking-luks2-volumes-with-tpm2-fido2-pkcs11-security-hardware-on-systemd-248.html" target="_blank" rel="noopener"
>systemd 248 版本新增的 systemd-cryptenroll&lt;/a> 让我能用 YubiKey 开机自动解密硬盘，避免输入一长串密码。以上组合使得我能参考的资料极其有限，仅仅 systemd-boot + Btrfs 的话看 Arch Wiki 足矣，但加上全盘加密后事情就变得相当复杂，&lt;a class="link" href="https://wiki.archlinux.org/title/Dm-crypt/Encrypting_an_entire_system#Btrfs_subvolumes_with_swap" target="_blank" rel="noopener"
>Arch Wiki 上的 Btrfs + LUKS 示例&lt;/a>是假设用户也加密 /boot 的（须 EFI 与 boot 分区不同），仅仅不加密 EFI，所以只能用 GRUB，而我的分区规划是把 EFI 分区挂载到 /boot（即两者为同一个东西），且我的威胁模型中也没有那么高级的攻击者，因此我不打算加密 /boot。不同的情况导致我不得不另外查找资料，所幸的是还能找到一篇 &lt;a class="link" href="https://nerdstuff.org/posts/2020/2020-004_arch_linux_luks_btrfs_systemd-boot/" target="_blank" rel="noopener"
>Installing Arch Linux with Btrfs, systemd-boot and LUKS&lt;/a>。根据这篇文章与 Arch Wiki 安装好了新系统，完成后确认可以通过密码解锁硬盘，然后还得研究如何使用 systemd-cryptenroll。按上面的文章配置是肯定不行的，initramfs 里都没有 systemd，开机根本就不会检测 YubiKey。为此我找到了一篇跟自己的需求较为相似的 &lt;a class="link" href="https://lemmy.eus/post/2898" target="_blank" rel="noopener"
>Setting up Arch + LUKS + BTRFS + systemd-boot + apparmor + Secure Boot + TPM 2.0&lt;/a>，尽管我不打算像这篇文章一样配置安全启动与 TPM 以自动解锁硬盘，但我们都是使用 systemd-cryptenroll 的，按照其中的思路修改一下配置，转而使用 YubiKey 是没问题的。systemd-cryptenroll 支持的设备类型非常广泛，FIDO 2、TPM 2 与 PKCS#11 都可以，而 YubiKey 则能充当以上除了 TPM 外的其它安全设备（除了贵以外没什么缺点），这里我把 YubiKey 当作 FIDO 2 设备使用。经过折腾，最终确认 /etc/mkinitcpio.conf 应该包含以下内容（应该还可以删减一些 Hook，懒得试了）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Bash" data-lang="Bash">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">HOOKS&lt;/span>&lt;span class="o">=(&lt;/span>base udev systemd autodetect modconf kms keyboard sd-vconsole block sd-encrypt btrfs filesystems fsck&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>/boot/loader/entries/arch.conf 则应该是（假设使用 linux 内核）：&lt;/p>
&lt;pre tabindex="0">&lt;code>title Arch Linux
linux /vmlinuz-linux
initrd /initramfs-linux.img
options rd.luks.name=&amp;lt;Your-UUID&amp;gt;=luks root=/dev/mapper/luks rootflags=subvol=@ rd.luks.options=&amp;lt;Your-UUID&amp;gt;=fido2-device=auto,discard rw
&lt;/code>&lt;/pre>&lt;p>这里提醒一下想照抄作业的读者，我并没有加密 /boot，没有启用安全启动，且在挂载加密盘时允许 discard，这都会降低安全性，如果对此比较在意请选择别的方案。&lt;/p>
&lt;h2 id="为什么选择-btrfs">为什么选择 Btrfs
&lt;/h2>&lt;p>此前我一直在用经典的 Ext4 作为使用 Linux 时的文件系统，但这么多年过去了，以下几点令我开始认真地考虑尝试使用 Btrfs：&lt;/p>
&lt;ol>
&lt;li>Btrfs 可以说已是成熟状态，&lt;a class="link" href="https://btrfs.readthedocs.io/en/latest/Status.html" target="_blank" rel="noopener"
>绝大部分功能已经稳定&lt;/a>，&lt;a class="link" href="https://www.linux.com/news/how-facebook-uses-linux-and-btrfs-interview-chris-mason/" target="_blank" rel="noopener"
>Facebook 也在生产环境中使用 Btrfs&lt;/a>。&lt;/li>
&lt;li>从 Ext4 迁移到 Btrfs 没有太多的痛苦（前提是不使用问题较多的 btrfs-convert 原地替换 Ext4，所以在新系统上使用是最简单的），基本不需要多少额外的配置，只要理解 Btrfs 的子卷怎么挂载就行，而常见的数据库与容器应用都会自动创建 Btrfs 的子卷，用户确实不需要怎么操心。&lt;/li>
&lt;li>数据安全性更有保障，默认采用 CoW（Copy on Write），带有 checksum 等措施使得意外丢失数据的可能性大大降低。当然，这并不能完全杜绝断电丢失最新写入数据的情况，因为数据的可靠保存不仅需要底层的支持，还需要上层应用的额外关注。另外，checksum 的存在使得文件的任何损坏都可以被及时发现，即使你的硬盘里的内容翻转了一比特都能被检测出来，避免了静默错误的出现（至于如何处理损坏的内容则是另一回事了）。&lt;/li>
&lt;li>还有一堆现代的特性，例如&lt;a class="link" href="https://wiki.archlinux.org/title/Btrfs#Compression" target="_blank" rel="noopener"
>透明压缩&lt;/a>，这个基本上每个人都会用到；快照，每次更新系统或折腾容易玩崩的东西前先拍个快照，方便一键还原；增量备份，通过&lt;a class="link" href="https://wiki.archlinux.org/title/Btrfs#Send/receive" target="_blank" rel="noopener"
>对子卷的 send/receive&lt;/a>，可以轻松地把子卷增量备份到另一个使用 Btrfs 的硬盘中。除此以外还有一些我暂时用不到的特性与功能，如 RAID、容量配额等等，具体可在 &lt;a class="link" href="https://wiki.archlinux.org/title/Btrfs" target="_blank" rel="noopener"
>Arch Wiki&lt;/a> 中查看。&lt;/li>
&lt;/ol>
&lt;p>当然，Btrfs 目前也还没到能受到所有人的欢迎的程度：它的读写速度要慢于 Ext4（CoW 的通病），而一旦检测到 checksum 出错则会强制要求用户进行处理也令有些人感到不爽。对于我来说，比较不满的一点是其本身没有加密功能，必须要与 LUKS 之类的方案一起使用才能达成全盘加密，希望未来能有更好的解决方案。&lt;/p>
&lt;h1 id="日常使用">日常使用
&lt;/h1>&lt;h2 id="kde">KDE
&lt;/h2>&lt;p>我在之前已经吐槽过安装 kde-applications 包组后会有一堆用不到的软件，甚至还写了一个&lt;a class="link" href="https://gist.github.com/vifly/33d1a4f63b0b7319c6db9af9d3bdbdb0" target="_blank" rel="noopener"
>简单的 Python 脚本&lt;/a>来删除它们。现在我发现更好的解决方法应该是在安装时就对此进行处理，根据我的需求这里给各位推荐一个安装 KDE 的方案。首先不要按 &lt;a class="link" href="https://wiki.archlinux.org/title/KDE#Plasma" target="_blank" rel="noopener"
>Arch Wiki&lt;/a> 上说的先安装 Xorg，直接安装 &lt;a class="link" href="https://archlinux.org/groups/x86_64/plasma/" target="_blank" rel="noopener"
>plasma 包组&lt;/a>即可，其中的依赖关系会导致 plasma 所需的 Xorg 组件也被安装，如果你需要使用 Wayland 的话请再安装 plasma-wayland-session 包。另外，安装包组有一个好处，那就是可以排除自己不想安装的软件包，例如我就排除了：&lt;/p>
&lt;pre tabindex="0">&lt;code>discover
milou
oxygen
oxygen-sounds
plasma-sdk
plasma-vault
plasma-workspace-wallpapers
&lt;/code>&lt;/pre>&lt;p>经过以上操作后已经装好了基础的桌面环境，但我们还需要配套的应用，而如果直接安装 kde-applications-meta 的话会装上一堆用不到的软件和游戏，选择 kde-applications 包组的话需要手动排除的项目也不少，更好的办法是根据 &lt;a class="link" href="https://gitlab.archlinux.org/archlinux/packaging/packages/kde-applications-meta/-/blob/main/PKGBUILD" target="_blank" rel="noopener"
>kde-applications-meta 的 PKGBUILD&lt;/a> 创建一个属于自己的 kde-applications-meta。这里给出我日常使用软件所构成的 &lt;a class="link" href="https://gist.github.com/vifly/253e3184f5a1d87c1292b131cba1c09c" target="_blank" rel="noopener"
>meta 包&lt;/a>，下载该 PKGBUILD 后在文件所处的目录下执行 &lt;code>makepkg -si&lt;/code> 即可。&lt;em>PS：如果你仔细查看该 PKGBUILD 就会发现里面没有包含 KDE 家的图片浏览器 gwenview，原因是我使用 nomacs 作为日常的图片浏览器。&lt;/em>&lt;/p>
&lt;h2 id="美化">美化
&lt;/h2>&lt;p>在我刚开始使用 KDE 后没多久就写过一篇&lt;a class="link" href="https://viflythink.com/KDE_to_Windows10/" target="_blank" rel="noopener"
> KDE 的美化教程&lt;/a>，探索了将 KDE 的外观变成 Windows 10 的可能性。经过了几年，由于 KDE 的版本更新导致部分选项有所改变，且我找到了一些更好的美化方案，所以抽空大改了一波上面的博文，想要美化自己的 KDE 桌面的童鞋继续查看该博文即可。&lt;/p>
&lt;h2 id="steam">Steam
&lt;/h2>&lt;p>就日常娱乐来说，Steam 当然是一个好选择，感谢 V 社一直以来对 Linux 游戏的支持（特别是其开发的 Proton 极大地扩充了 Linux 下可游玩的游戏范围），现在 Linux 下大部分游戏的体验已经不亚于 Windows，只需要打开 Steam 一键安装就能开玩。不过对于一个强迫症来说，Steam 及其安装的游戏在家目录下乱扔垃圾这点还是令我挺不爽的。之前我一直在用 &lt;a class="link" href="https://liolok.com/zhs/containerize-steam-with-systemd-nspawn/" target="_blank" rel="noopener"
>systemd-nspawn&lt;/a> 隔离相关应用，但后来发现为此专门准备一个容器所占的空间太大了点，而且隔离级别较高还要解决一些游戏的运行问题，于是在新系统上决定尝试改用 Flatpak 作为安装与使用 Steam 的方式（虽然 Flatpak 会创建 ~/.var 这个目录）。首先根据 &lt;a class="link" href="https://wiki.archlinux.org/title/steam#Flatpak" target="_blank" rel="noopener"
>Arch Wiki&lt;/a> 先安装 Steam 本体，再加上一些个人使用的配套应用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Bash" data-lang="Bash">&lt;span class="line">&lt;span class="cl">flatpak install flathub com.valvesoftware.Steam com.valvesoftware.Steam.Utility.protontricks com.valvesoftware.SteamLink
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后直接在开始菜单找到并启动 Steam 看看效果，基本上与在本机系统内直接安装 steam 没什么区别。如果中文字体不对劲，安装 ttf-liberation 应该能解决。&lt;/p>
&lt;p>如果你使用 KDE 且安装了 flatpak-kcm 这个包，此时便可以在系统设置中的“应用程序”-&amp;gt;“Flatpak 权限设置”中对安装的 Flatpak 应用进行管理，比如设置更细分的权限与应用运行时的环境变量等等。举个例子，这里我就给 Steam 创建了一个新的 Btrfs 子卷（挂载到 /games）用于安装游戏：&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/New-Install-Arch/set_flatpak_steam_fs_access.png"
width="1466"
height="1026"
loading="lazy"
alt="set_flatpak_steam_fs_access"
class="gallery-image"
data-flex-grow="142"
data-flex-basis="342px"
>&lt;/p>
&lt;p>除此以外，如果你因没有配置透明代理而在使用 Steam 时撞到墙，那么可以通过修改 desktop 文件让 Steam 使用代理。具体做法是，先执行 &lt;code>cp /var/lib/flatpak/exports/share/applications/com.valvesoftware.Steam.desktop ~/.local/share/applications/&lt;/code> 把 Steam 的 desktop 文件复制到用户目录下，然后开始修改对应复制过来的文件，在 &amp;ldquo;Actions=&amp;rdquo; 开头的一行把 &amp;ldquo;RunWithProxy;&amp;rdquo; 添加到该行末尾，然后在文件的末尾添加以下内容：&lt;/p>
&lt;pre tabindex="0">&lt;code>[Desktop Action RunWithProxy]
Name=Run with proxy
Name[zh_CN]=使用代理运行
Name[zh_TW]=使用代理運行
Exec=/usr/bin/flatpak run --branch=stable --arch=x86_64 --command=/app/bin/steam-wrapper --file-forwarding --env=https_proxy=http://127.0.0.1:1090 com.valvesoftware.Steam -tcp @@u %U @@
&lt;/code>&lt;/pre>&lt;p>以上的 Exec 就是在原来的默认值上加了两个参数，让 Steam 使用 TCP 连接，以遵循新增的 https_proxy 环境变量，记得把 https_proxy 修改为自己的 HTTP 代理地址与端口号，这里提供一下&lt;a class="link" href="https://gist.github.com/vifly/ccdfd05899263e43ed269bbca8ec40f4" target="_blank" rel="noopener"
>我修改后的文件&lt;/a>以供参考。保存好文件后将其链接到 ~/Desktop 下，在需要让 Steam 翻墙时，只需右键点击桌面上的 Steam 图标然后选择“使用代理运行”即可。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/New-Install-Arch/run_steam_with_proxy.png"
width="463"
height="766"
loading="lazy"
alt="run_steam_with_proxy"
class="gallery-image"
data-flex-grow="60"
data-flex-basis="145px"
>&lt;/p>
&lt;h2 id="输入法">输入法
&lt;/h2>&lt;p>目前我已经把输入法方案从 Fcitx4 + RIME 切换到了 Fcitx5 自带的拼音输入法。当年使用 RIME 的主要原因是包括 google pinyin 在内 Fcitx4 自带的拼音输入法的候选词算法都十分糟糕，而现在 fcitx5-chinese-addons 里的拼音输入法已经足够好用，与 RIME 相比，Fcitx5 拼音输入法更开箱即用，候选词算法更优秀，同时在可折腾性上也不输 RIME，支持 Lua 插件、导入第三方词库、输入法皮肤、快速输入 Emoji 与特殊 Unicode 等功能。所以除非有什么非常需要的 RIME 独占功能，否则我都一律推荐使用 Fcitx5 拼音输入法。&lt;/p>
&lt;p>只需根据 &lt;a class="link" href="https://wiki.archlinuxcn.org/wiki/Fcitx5" target="_blank" rel="noopener"
>Arch Wiki&lt;/a> 安装好对应的包组与包后重启即可：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Bash" data-lang="Bash">&lt;span class="line">&lt;span class="cl">sudo pacman -S fcitx5-im fcitx5-lua fcitx5-chinese-addons
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>另外，想在 Android 手机上使用 Fcitx5 拼音输入法的童鞋可以尝试 &lt;a class="link" href="https://github.com/fcitx5-android/fcitx5-android" target="_blank" rel="noopener"
>fcitx5-android&lt;/a> 这个项目。目前日常使用所需的功能已全部就位，可以确保在手机上也有与电脑相同的输入体验。&lt;/p>
&lt;h2 id="其它">其它
&lt;/h2>&lt;p>我的音频播放器从 Rhythmbox 切换到了同属 Gnome 家的 Lollypop（KDE 请加油），与 Rhythmbox 相比，Lollypop 的界面更为现代（见下图），还支持自动从互联网下载歌曲封面图片，搜索歌词等功能。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/New-Install-Arch/Lollypop.png"
width="1305"
height="968"
loading="lazy"
alt="Lollypop"
class="gallery-image"
data-flex-grow="134"
data-flex-basis="323px"
>&lt;/p>
&lt;p>而笔记工具则令我颇为头疼，考虑到前不久 &lt;a class="link" href="https://news.ycombinator.com/item?id=36609641" target="_blank" rel="noopener"
>Evernote 的新母公司裁掉了几乎所有员工&lt;/a>的新闻，尽管后来解释称是准备将运营团队转移至欧洲，因而裁掉了原来的员工，但我实际上在 Evernote 被收购时就已经对 Evernote 的前景感到担忧，所以早就想物色一个新的笔记工具了。最近流行的笔记工具都声称自己受到了 &lt;a class="link" href="https://zettelkasten.de/introduction/" target="_blank" rel="noopener"
>Zettelkasten&lt;/a>（卡片盒）笔记法的启发，设计出了从根基上与 Evernote 这种“传统”笔记不同的结构，例如 Logseq、Obsidian、Notion、Emacs 的 org-roam 等。对于是否迁移到它们之一，或继续坚守“传统”，我目前还在犹豫，欢迎各位读者向我推荐自己喜欢的笔记软件。无论如何，先用 &lt;a class="link" href="https://github.com/vzhd1701/evernote-backup" target="_blank" rel="noopener"
>evernote-backup&lt;/a> 导出笔记后用 &lt;a class="link" href="https://github.com/akosbalasko/yarle" target="_blank" rel="noopener"
>Yarle&lt;/a> 转为 markdown 做好最坏情况下的准备总是没错的，至少目前 Evernote 还保持着一贯的开放 API，使得迁移笔记还没什么问题。&lt;/p>
&lt;p>还有之前没有推荐过的 KDE Connect，它可以实现手机与电脑的互联，例如同步通知、互传文件、多媒体控制、远程执行命令等，强大到足以被称为开源法拉利，而 Gnome 用户也可以使用 &lt;a class="link" href="https://extensions.gnome.org/extension/1319/gsconnect/" target="_blank" rel="noopener"
>GSConnect 扩展&lt;/a>享受到同样的功能。&lt;/p></description></item><item><title>从 Material 主题迁移到 Stack 主题</title><link>https://viflythink.com/Migrate_from_Material_to_Stack/</link><pubDate>Sun, 21 Nov 2021 00:00:00 +0800</pubDate><guid>https://viflythink.com/Migrate_from_Material_to_Stack/</guid><description>&lt;img src="https://viflythink.com/Migrate_from_Material_to_Stack/show.jpg" alt="Featured image of post 从 Material 主题迁移到 Stack 主题" />&lt;p>在用了近三年的 Material 主题后，我终于决定更换博客主题了。尽管当初在我开始写博客时，Material 主题已经不维护了，但我暂时没找到更符合自己需求的主题，于是便一直用到了现在。当然，那时的我已经有将来会更换主题的预感了，而如今这一只脚终于落地，给博客换上了看上去更现代的 &lt;a class="link" href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener"
>Stack 主题&lt;/a>，也从 Hexo 迁移到了 Hugo，于是写下本文说明一下相关的经过（&lt;del>又能水一篇博文了&lt;/del>）。&lt;/p>
&lt;h1 id="为什么要换主题">为什么要换主题
&lt;/h1>&lt;p>先列举一下旧方案的不足吧。Material 主题并不差，设计风格符合我的胃口，而且提供了我所需要的功能，但用了这么久，由于各种原因令我想更换博客主题：&lt;/p>
&lt;ol>
&lt;li>Material 主题已经不再维护，这是最核心的一个问题，考虑到前端圈在兼容性方面的“良好”名声，我毫不怀疑哪天 NodeJS 或 Hexo 一个更新就会令我的博客没法构建&lt;/li>
&lt;li>感觉当年的 Material Design 有点跟不上时代了（喜新厌旧），另外展开侧边栏时的动画给我的感觉有点慢，令我不禁怀疑在 PC 端模拟 Android 端 Material Design App 的必要性&lt;/li>
&lt;li>友链界面的卡片有一点问题，当描述较长时会出现文字溢出的问题，原本打算咬咬牙修一下 CSS 的，但想到迟早要换博客主题，不如赶快换了主题再处理友链界面&lt;/li>
&lt;/ol>
&lt;p>另外，还是由于偏主观的对前端工具链的不信任，我不想再用 Hexo 了，切换到使用自己更熟悉的语言写的静态站点生成器至少能确保在出现问题时我可以尝试自己动手修一修，所以 Python 写的 Pelican 和 Go 写的 Hugo 对我来说都是不错的选择（&lt;em>PS：为什么还没人用 Rust 造一个强大的静态站点生成器&lt;/em>）。&lt;/p>
&lt;h1 id="迁移过程">迁移过程
&lt;/h1>&lt;p>先根据 &lt;a class="link" href="https://gohugo.io/getting-started/quick-start/" target="_blank" rel="noopener"
>Hugo 官方的 Quick Start&lt;/a> 下载 Stack 主题并建了一个简单的站点，然后一步步把博客原有的配置迁移过去。&lt;/p>
&lt;p>其中比较费时间且烦琐的步骤包含把 Stack 主题提供的示例配置从 YAML 改为了 &lt;a class="link" href="https://github.com/vifly/blog/blob/main/config.toml" target="_blank" rel="noopener"
>TOML 文件&lt;/a>（非必要，个人偏好原因）；以及更改文章源码的结构：原本我是把所有的 Markdown 文件放在一个文件夹下，文章配图放到另外的文件夹，现在由于 Stack 主题的要求我给每篇博文新建了文件夹并把配图移动到对应博文所在的文件夹。&lt;/p>
&lt;p>由于不是新建博客而是迁移博客，所以我还处理了 URL 相关的问题，确保原来的 URL 不变。在迁移前，我的 Markdown 文件都是像 Python_GIL_and_concurrency.md 这样首字母与专有名词大写，下划线用于分割单词的格式，Hexo 生成的博文 URL 与文件名相同；迁移后，每篇博文都放到单独的文件夹，具体存放结构可在&lt;a class="link" href="https://github.com/vifly/blog/tree/main/content/post" target="_blank" rel="noopener"
>此&lt;/a>查看，按照 Stack 主题给的示例所生成的博文 URL 则是 viflythink.com/&amp;lt;文章标题&amp;gt;/ 的格式，我经过谷歌后按照 &lt;a class="link" href="https://gohugo.io/content-management/urls/" target="_blank" rel="noopener"
>Hugo 文档&lt;/a>设定了新的 URL 生成规则：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Toml" data-lang="Toml">&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="nx">permalinks&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">post&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;/:filename/&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">page&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;/:slug/&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样就会用文件夹的名字而不是用文章标题来生成 URL，当然，这还不够，生成的 URL 虽然用的是文件夹的名字，但全都转为了小写字母，然后找到&lt;a class="link" href="https://www.jvt.me/posts/2019/11/10/hugo-case-sensitive-urls/" target="_blank" rel="noopener"
>这篇文章&lt;/a>让 Hugo 生成大小写敏感的 URL：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Toml" data-lang="Toml">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">disablePathToLower&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>除了博文的 URL 外，还需要处理 RSS 订阅地址，原来的 RSS 地址是 viflythink.com/atom.xml ，可 Stack 默认产生 viflythink.com/index.xml 作为 RSS 地址，于是我又谷歌找到了 &lt;a class="link" href="https://discourse.gohugo.io/t/how-can-i-change-the-rss-url/118" target="_blank" rel="noopener"
>Hugo 论坛的讨论&lt;/a>，据此修改了设置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Toml" data-lang="Toml">&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="nx">outputFormats&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">RSS&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">mediatype&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;application/rss&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">baseName&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;atom&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>除了让 URL 保持不变外，我还设法把原本对 Material 主题修改的代码也迁移了过来。这里不得不提到 Hugo 的 &lt;a class="link" href="https://gohugo.io/hugo-modules/theme-components/" target="_blank" rel="noopener"
>Theme Components&lt;/a>，通过它我可以在站点根目录下建立同样结构的目录以覆盖主题的部分内容，也就是说不用直接对主题的源代码动手了，接下来的修改都是靠这个特性完成的，具体可参考 &lt;a class="link" href="https://docs.stack.jimmycai.com/zh/modify-theme/" target="_blank" rel="noopener"
>Stack 的修改主题章节&lt;/a>。&lt;/p>
&lt;p>与 Material 主题相同，Stack 没有提供 Isso 评论系统，新建 &lt;a class="link" href="https://github.com/vifly/blog/blob/main/layouts/partials/comments/provider/isso.html" target="_blank" rel="noopener"
>layouts/partials/comments/provider/isso.html&lt;/a> 并按 &lt;a class="link" href="https://posativ.org/isso/docs/configuration/client/" target="_blank" rel="noopener"
>Isso 文档&lt;/a>的说明把内容复制粘贴进去就能添加对 Isso 的支持了（别忘了修改站点配置文件）。&lt;/p>
&lt;p>还有验证网站所有权与插入 Matomo 统计代码都是通过新建与修改 &lt;a class="link" href="https://github.com/vifly/blog/blob/main/layouts/partials/head/custom.html" target="_blank" rel="noopener"
>layouts/partials/head/custom.html&lt;/a> 完成的。设置 CNAME 让 viflythink.com 指向 vifly.github.io 则是新建 &lt;a class="link" href="https://github.com/vifly/blog/blob/main/static/CNAME" target="_blank" rel="noopener"
>/static/CNAME&lt;/a>来完成（来源：&lt;a class="link" href="https://gohugo.io/hosting-and-deployment/hosting-on-github/#use-a-custom-domain" target="_blank" rel="noopener"
>Hugo 文档&lt;/a>）。&lt;/p>
&lt;p>我还想把随机标语也迁移到 Stack 上，这就需要覆盖主题原本的文件了。把 themes/hugo-theme-stack/layouts/partials/sidebar/left.html 复制为 &lt;a class="link" href="https://github.com/vifly/blog/blob/main/layouts/partials/sidebar/left.html" target="_blank" rel="noopener"
>layouts/partials/sidebar/left.html&lt;/a>，然后对 &lt;code>&amp;lt;h2 class=&amp;quot;site-description&amp;quot;&amp;gt;{{ .Site.Params.sidebar.subtitle }}&amp;lt;/h2&amp;gt;&lt;/code> 进行修改，具体的修改可看我的代码，如何在 Gist 存放标语内容则请看我的旧博文&lt;a class="link" href="https://viflythink.com/Use_GithubPages_and_Hexo_to_build_blog_advanced/" target="_blank" rel="noopener"
>《使用 GitHub Pages 和 Hexo 搭建个人博客(进阶篇)》&lt;/a>中的“Material 主题实现随机显示标语（slogan）”一节。&lt;em>PS：翻阅旧博文后发现自己的前端技术也有所进步了，当年只会用一下 jQuery，而现在直接用 Vanilla JS 的 fetch 就完成了相同的任务&lt;/em>。为了让修改后的侧边栏看上去更好，我还微调了一下样式，具体可看 &lt;a class="link" href="https://github.com/vifly/blog/tree/main/assets/scss/partials" target="_blank" rel="noopener"
>assets/scss/partials&lt;/a> 下的内容。&lt;/p>
&lt;p>最后，我还把博客的构建从本地搬到了 GitHub Actions 上，当我把修改的 Markdown 文件推送到 GitHub 后博客就会自动更新，再也不用在本地构建好后再推送到 GitHub Page 所在的仓库了。&lt;/p>
&lt;p>总的来说，迁移过程可说是十分平滑，没有踩到任何大坑就把博客迁移到 Stack 主题了，甚至没花多少时间就把对 Material 主题的修改也搬了过来。&lt;/p>
&lt;h1 id="新变化">新变化
&lt;/h1>&lt;p>既然把博客主题换了，那肯定要对比一下迁移前后的外观。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Migrate_from_Material_to_Stack/material_blog_homepage.png"
width="1877"
height="940"
loading="lazy"
alt="使用 Material 主题的博客主页"
class="gallery-image"
data-flex-grow="199"
data-flex-basis="479px"
>&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Migrate_from_Material_to_Stack/stack_blog_homepage.jpg"
width="1886"
height="900"
loading="lazy"
alt="使用 Stack 主题的博客主页"
class="gallery-image"
data-flex-grow="209"
data-flex-basis="502px"
>&lt;/p>
&lt;p>Stack 主题是典型的三栏式布局，右侧栏包括了常用的跳转链接与搜索功能，而 Material 则是单栏，侧边栏需要点击按钮才会出现。至于在主页上的博文呈现，两者都是卡片风格，同样是由上到下的图片 -&amp;gt; 标题 -&amp;gt; 文章摘要这样组成的布局。可以看出两者给人的感受有所区别，迁移到 Stack 主题后我博客的风格更柔和多彩了，这得益于圆角的使用与主题配色的区别，当然，也与我在迁移后给文章配上精心挑选的图片有关，之前的文章图片都是由 Material 自动生成的，虽然也挺好看，体现了 Material Design 的简洁风格，但看久了后总会觉得千篇一律。&lt;/p>
&lt;p>除了外观上的变化，细心的读者可能会发现，在迁移后，我的博客左侧栏多了 &lt;a class="link" href="https://viflythink.com/service/" target="_blank" rel="noopener"
>Service&lt;/a> 这一个链接，这是我新增的一个页面，用于列举出目前我提供的服务，当提供的服务有改动时，该页面也会有所说明。&lt;/p>
&lt;p>另外，有一个读者无法察觉但我能明显感知到的变化：迁移后的博客构建速度变快了。这大概是 Hugo 的优化比 Hexo 好导致的，不过并不能完全怪罪 Hexo，因为这也与我之前用的 Material 主题许久不更新，没有用上 Hexo 的用于加快构建速度的新特性有关。总之目前的构建速度终于让我感到舒服了，能够快速看到改动效果这一点在修改主题样式时十分有用。&lt;/p>
&lt;h1 id="总结">总结
&lt;/h1>&lt;p>我有时会开玩笑说：“写博客哪有写博客主题有意思”，包括这次迁移在内，看着刚开始时一个标准的模板被改造成了自己想要的样子的确很有意思，但我认为开设博客的目的更应该是写一些自己觉得有价值的内容，博客的外观与设计的确很重要，体现了博主的品位与喜好，但世界上并不缺少能展示自己品位的方法，写博客却是少有的通过文字阐述观点、分享知识与经历的行为，所以我会尽量不让与网站相关的博文占到总博文数的一半，而是尽量让博客涉及更多领域的内容，这也是我为本博客所设立的一个目标。&lt;/p>
&lt;p>最后，希望本次愉快的博客迁移能激励我提高一些更新博客的频率（咕咕咕）。最近来说，我也有了一些新想法，考虑到不是所有的新想法都有必要写一篇博文来说明，未来我可能会在其它平台（Twitter、Telegram 频道等）或另一个自建站点记录与说明这些东西，也可能会考虑建立公开 Wiki 知识库这样的站点来分享自己的知识，总之这些都是目前只存在于脑海中的想法，这些任务就交给未来的自己了。本篇水文到此结束，谢谢有耐心读到最后的读者。&lt;/p></description></item><item><title>使用 Vercel 与 OneDrive 自建软件源</title><link>https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo/</link><pubDate>Sat, 04 Sep 2021 00:00:00 +0800</pubDate><guid>https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo/</guid><description>&lt;img src="https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo/show.jpg" alt="Featured image of post 使用 Vercel 与 OneDrive 自建软件源" />&lt;p>&lt;em>2021.11.12.更新：增加了关于 GPG 签名的说明。&lt;/em>
&lt;em>2024.11.23.更新：现在支持上传软件包到其它 Rclone 支持的云存储了，所以更新了对 uploadToOneDrive job 的说明。&lt;/em>&lt;/p>
&lt;p>大家好，又是本鸽子久违的博客更新。之前的&lt;a class="link" href="https://viflythink.com/Use_GitHubActions_to_build_AUR" target="_blank" rel="noopener"
>《GitHub Actions 打造 AUR 打包下载一条龙服务》&lt;/a>已经折腾出了完全白嫖的编译机，可好景不长，当我的机器数量变多后，我发现在每台机器上运行脚本下载软件包的确有点麻烦，与其自己写一个脚本下载软件包，还不如直接自建一个软件源呢。经过一番研究后，我盯上了 OneDrive 与 Vercel 这两个可以免费使用的服务，通过它们实现了自建一个完全免费而且在国内外都可高速访问的软件源。&lt;/p>
&lt;p>本文是对&lt;a class="link" href="https://viflythink.com/Use_GitHubActions_to_build_AUR" target="_blank" rel="noopener"
>《GitHub Actions 打造 AUR 打包下载一条龙服务》&lt;/a>的扩展，如果你还没有读过该博文，请先读完它再回来阅读本文。通过前文与本文，你可以在没有服务器，不花一分钱的情况下搭建一个基于 OneDrive 的高速自建软件仓库，体验到白嫖与折腾 Linux 的双重快乐。&lt;/p>
&lt;p>为了得到一个公开的软件仓库，只是把软件包构建出来并放到 GitHub Release 是不够的，没有软件包数据库，软件包管理器可不知道如何获取这些软件包，更不用提校验与安装等等。生成软件包数据库只需要一行 &lt;code>repo-add ./reponame.db.tar.gz *.tar.zst&lt;/code>，然后把它们都放到 GitHub Release 这样的免费存储后端就可以解决分发问题了，实际上有一个 &lt;a class="link" href="https://github.com/Brx86/repo" target="_blank" rel="noopener"
>arch-build 的 fork&lt;/a> 就是这样做的。当然，我对其还是不够满意，通过 fastgit 等 GitHub 反代服务的确可以加速 GitHub Release 的下载速度，但还是不够稳定；还有一个更重要的原因，我不仅想要自建 Arch 软件源，也想要自建 Debian 软件源，而 GitHub Release 的路径不够灵活，无法构造像 yourrepo.com/debian/pool/main/n/nginx/ 这样的 URL，没法满足自建 Debian 软件源的需求。所以嘛，只能自己再造一个轮子了。&lt;/p>
&lt;p>在看下文之前，不妨先打开&lt;a class="link" href="https://archrepo.viflythink.com/" target="_blank" rel="noopener"
>我的自建仓库&lt;/a>页面查看最终效果，如果想使用我的自建软件源，需要先执行以下指令导入 GPG 公钥：&lt;/p>
&lt;pre tabindex="0">&lt;code>wget -O /tmp/vifly-repo.key &amp;#39;https://share.viflythink.com/arch-repo.key&amp;#39; &amp;amp;&amp;amp; sudo pacman-key --add /tmp/vifly-repo.key
sudo pacman-key --lsign-key viflythink@gmail.com
&lt;/code>&lt;/pre>&lt;p>然后在 /etc/pacman.conf 末尾添加下面几行后执行 pacman -Syu：&lt;/p>
&lt;pre tabindex="0">&lt;code>[vifly]
Server = https://archrepo.viflythink.com
&lt;/code>&lt;/pre>&lt;p>尽管本文最终提供的成品目前只用在 Arch 自建源上，但对脚本稍加修改后也可以用来自建其它 Linux 发行版的软件仓库。&lt;/p>
&lt;h1 id="上传到-onedrive">上传到 OneDrive
&lt;/h1>&lt;p>之前配置的 GitHub Actions 已经可以把软件包上传到 Release 上，现在只需要对原来的配置文件稍加改造就可以让 GitHub Actions 把软件包也上传到 OneDrive，为了尽量不重复造轮子，在这里我选择了 Rclone 进行上传，它提供了非常完善的文件传输功能，例如上传或下载时遇到文件内容相同的情况会自动跳过。&lt;/p>
&lt;h2 id="在-azure-创建应用">在 Azure 创建应用
&lt;/h2>&lt;p>根据 &lt;a class="link" href="https://rclone.org/onedrive/#getting-your-own-client-id-and-key" target="_blank" rel="noopener"
>Rclone 的官方文档&lt;/a>操作即可，以下给出图文操作步骤。尽管 Rclone 官方认为这是可选的，但在 Vercel 部署直链下载应用时也需要在 Azure 创建应用获取 Token，所以便把相关步骤放这里了，另外基于权限最小化的原则，这里我们创建的是一个拥有读写权限的应用，而在 Vercel 部署时则是创建一个具有只读权限的应用，两个应用用在不同的地方，这样可有效提升安全性。&lt;/p>
&lt;p>打开 &lt;a class="link" href="https://portal.azure.com/#blade/Microsoft_AAD_RegisteredApps/ApplicationsListBlade" target="_blank" rel="noopener"
>Azure 的应用管理页面&lt;/a>，点击 New registration。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo/azure_applist.png"
width="1914"
height="786"
loading="lazy"
alt="Azure 应用列表"
class="gallery-image"
data-flex-grow="243"
data-flex-basis="584px"
>&lt;/p>
&lt;p>在打开的界面中输入应用的名字（这里我用了 rclone 这个名字），Supported account types 这一项选择图中的第二项（也是包含范围最广泛的那项），在 Redirect URI (optional) 这一项选择 Web 并在右边的输入框里输入 http://localhost:53682/ 这一网址。完成后点击 Register。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo/azure_app_register.png"
width="1904"
height="878"
loading="lazy"
alt="Azure 注册应用"
class="gallery-image"
data-flex-grow="216"
data-flex-basis="520px"
>&lt;/p>
&lt;p>此时应用已经注册完成，记录下 Application (client) ID 的值，这就是下文会用到的 client id。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo/azure_get_client_id.png"
width="1918"
height="876"
loading="lazy"
alt="Azure 获取 client id"
class="gallery-image"
data-flex-grow="218"
data-flex-basis="525px"
>&lt;/p>
&lt;p>点击左侧菜单的 Certificates &amp;amp; secrets，然后点击 New client secret，在 Description 一栏随便填点什么，把 Expires（过期时间）设为最长的 24 months（两年后记得更新 client secret），点击 Add。最后记录下新增的 client secret 的值（在图中标注的 Value）。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo/azure_get_client_secret.png"
width="1918"
height="897"
loading="lazy"
alt="Azure 获取 client secret"
class="gallery-image"
data-flex-grow="213"
data-flex-basis="513px"
>&lt;/p>
&lt;p>到此为止就完成了。有些同学可能会感到奇怪：Rclone 文档中不是还有第 4 与第 5 步设置权限吗？根据我的实测，这两步并没有必要执行，所以这里不会附上这两步操作的示意图。&lt;/p>
&lt;h2 id="获取-token">获取 Token
&lt;/h2>&lt;p>在本地安装 Rclone（&lt;code>pacman -S rclone&lt;/code>），运行 rclone config 进入交互式配置流程，接着&lt;a class="link" href="https://rclone.org/onedrive" target="_blank" rel="noopener"
>一步步地按照提示操作&lt;/a>，当程序询问 Microsoft App Client Id 和 Microsoft App Client Secret 时，填入上一小节中记录的对应值。&lt;/p>
&lt;p>完成配置后 Rclone 会把配置数据存放在 ~/.config/rclone/rclone.conf，使用 &lt;code>cat ~/.config/rclone/rclone.conf&lt;/code> 查看。如下所示，下文的 RCLONE_CONFIG 就需要把这些东西复制粘贴进去。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-INI" data-lang="INI">&lt;span class="line">&lt;span class="cl">&lt;span class="k">[xxx]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">type&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">onedrive&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">client_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">xxx&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">client_secret&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">xxx&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">region&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">global&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">drive_type&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">personal&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">token&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">{&amp;#34;access_token&amp;#34;:&amp;#34;xxx&amp;#34;,&amp;#34;token_type&amp;#34;:&amp;#34;Bearer&amp;#34;,&amp;#34;refresh_token&amp;#34;:&amp;#34;xxx&amp;#34;,&amp;#34;expiry&amp;#34;:&amp;#34;xxx&amp;#34;}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">drive_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">xxx&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="配置-github-actions">配置 GitHub Actions
&lt;/h2>&lt;p>首先 fork &lt;a class="link" href="https://github.com/vifly/arch-build" target="_blank" rel="noopener"
>arch-build 仓库&lt;/a>，如果你在之前已经使用了它，记得同步到最新版本。与前文所给的例子相比，现在的 workflow 文件（.github/workflows/build.yml）多了 uploadToOneDrive 这一个 job，虽然我这里用的是 OneDrive，但其实你也可以用它把软件包上传到其它 Rclone 支持的云存储上。&lt;/p>
&lt;p>${{ secrets.xxx }} 这样的变量都是需要在 GitHub 的项目配置中的 Secrets 一栏设置的私密变量，打开项目的 Settings，找到下图所示的界面，然后点击 New repository secret，并填入 RCLONE_CONFIG 这个变量的值（把上一小节的 rclone.conf 内容复制粘贴进去即可）。具体的操作也可参考 &lt;a class="link" href="https://docs.github.com/en/actions/reference/encrypted-secrets#creating-encrypted-secrets-for-a-repository" target="_blank" rel="noopener"
>GitHub 官方文档&lt;/a>。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo/github_actions_add_secret.png"
width="1752"
height="1026"
loading="lazy"
alt="GitHub Actions 添加私密变量"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="409px"
>&lt;/p>
&lt;p>接着回来修改 workflow 文件，dest_path 是 OneDrive 上传的目的地路径（如果该路径不存在，Rclone 会自动创建），以 Linux 文件路径的形式填写即可，不建议使用根路径，因为接下来将会把这个路径下的所有东西公开，各位肯定不希望别人打开你的软件仓库页面时还看到其它乱七八糟的文件；repo_name 是你的自建软件仓库的名字，&lt;a class="link" href="https://wiki.archlinux.org/title/Pacman/Tips_and_tricks#Custom_local_repository" target="_blank" rel="noopener"
>它用于 repo-add 的参数&lt;/a>。&lt;/p>
&lt;p>为了安全，建议为自己的软件源添加 GPG 签名，不签名的话，pacman.conf 中的仓库配置需要加上 &lt;code>SigLevel = Never&lt;/code> 禁用签名校验才能使用。如果你想为自己的软件源添加 GPG 签名的话，建议先生成一个单独的 GPG 密钥对（不要设置密码），而不是使用原有的密钥对，并导出私钥：&lt;/p>
&lt;pre tabindex="0">&lt;code>gpg --gen-key
gpg --armor --export-secret-keys your_keyid &amp;gt; private.key
&lt;/code>&lt;/pre>&lt;p>回到 GitHub 的项目配置新增 Secrets，Name 为 gpg_private_key，Value 则是导出的私钥内容。最后在 workflow 文件的 uploadToOneDrive job 的参数加上 gpg-privatekey: ${{ secrets.gpg_private_key }}（即 dest_path、repo_name 等配置所在的位置）。现在得到的软件源将具有 GPG 签名，需要按以下步骤导入公钥才能使用：&lt;/p>
&lt;pre tabindex="0">&lt;code>gpg --armor --export your_keyid &amp;gt; public.key
sudo pacman-key --add public.key
sudo pacman-key --lsign-key your_keyid
&lt;/code>&lt;/pre>&lt;p>为了节省存储空间，这个 job 只会在 OneDrive 存储最新版本的软件包，不像 Arch 官方软件仓库那样还提供了归档。如果你对使用 Rclone 同步到 OneDrive 或构建软件包数据库的细节感兴趣，那么可以查看 &lt;a class="link" href="https://github.com/vifly/arch-build/blob/master/create-db-and-upload-action/entrypoint.sh" target="_blank" rel="noopener"
>entrypoint.sh&lt;/a> 脚本了解细节，不到三十行便完成了这些工作（其实是因为我把复杂的逻辑用 Python 实现了）。&lt;/p>
&lt;h1 id="在-vercel-部署直链下载应用">在 Vercel 部署直链下载应用
&lt;/h1>&lt;p>上面我们已经把软件包成功放到了 OneDrive 中，OneDrive 本身也有分享功能，可是它的分享链接地址没有任何的规律，Pacman 可不知道一个软件包对应的下载地址与 OneDrive 分享地址的联系，它只认 yourrepo.com/package 这样的下载地址（Apt 等包管理器认的 URL 更复杂，但依然有明显的规律），所以我们需要一个应用来实现链接的转换，这就是直链下载应用要干的事情。&lt;/p>
&lt;p>GitHub 上已经有不少 onedrive index 项目实现 OneDrive 的直链下载，我嫌它们提供的功能太多了（没忍住自造轮子的冲动），所以也用 Python 造了一个非常简陋的应用 &lt;a class="link" href="https://github.com/vifly/urepo" target="_blank" rel="noopener"
>urepo&lt;/a>，支持在 Vercel 上部署，也支持直接在 VPS 上部署，它和 Rclone 一样采用了微软官方提供的 API 实现提取文件下载链接的功能。下文将使用 urepo 实现直链下载，如果你之前已经部署了其它的 onedrive index 应用，那参照下文继续用原来的应用也是可以的。&lt;/p>
&lt;h2 id="获取访问令牌">获取访问令牌
&lt;/h2>&lt;p>既然 urepo 和 Rclone 一样采用了微软官方提供的 API，那么它同样也要像使用 Rclone 那样获取访问令牌。回到上面的“在 Azure 创建应用”这一小节，按同样的步骤再创建一个应用，只是这次的 Redirect URI (optional) 应输入 http://localhost/ ，完成后得到 client id 与 client secret。&lt;/p>
&lt;p>与上面依靠 Rclone 获取 Token 不同的是，这次则是使用一个脚本获取 Token，它不会像 Rclone 那样申请写入权限。下载我写好的&lt;a class="link" href="https://github.com/vifly/urepo/blob/main/client-tools/get_deploy_config.py" target="_blank" rel="noopener"
>获取 Token 脚本&lt;/a>与&lt;a class="link" href="https://github.com/vifly/urepo/blob/main/client-tools/config.py.example" target="_blank" rel="noopener"
>配置示例&lt;/a>，并确保已经安装了 Python 的 Requests 库（&lt;code>pacman -S python-requests&lt;/code>），然后把配置示例（config.py.example）重命名为 config.py，并填入 CLITENT_ID 与 CLITENT_SECRET。&lt;/p>
&lt;p>运行脚本：&lt;/p>
&lt;pre tabindex="0">&lt;code>cd downloadpath
python3 get_deploy_config.py
&lt;/code>&lt;/pre>&lt;p>根据提示操作，最后得到 code 与 refresh_token。此时我们已经获得 client id、client secret、code、refresh_token 这四项配置。至于下文中需要用到的 path，那就是在“配置 GitHub Actions”这一小节中的 dest_path。&lt;/p>
&lt;h2 id="部署到-vercel">部署到 Vercel
&lt;/h2>&lt;p>&lt;a class="link" href="https://vercel.com/" target="_blank" rel="noopener"
>Vercel&lt;/a> 是一个免费的应用部署平台，主要用来测试和部署 Serverless 应用，通过它，我们可以零成本地部署直链下载应用。Vercel 提供了两种部署方式，从下面两种方式任选其一执行即可。&lt;/p>
&lt;h3 id="打开链接部署推荐">打开链接部署（推荐）
&lt;/h3>&lt;p>注册或登录你的 Vercel 账号，然后打开我创建的&lt;a class="link" href="https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fvifly%2Furepo&amp;amp;env=code,path,client_secret,client_id,refresh_token" target="_blank" rel="noopener"
>部署链接&lt;/a>，会出现如下界面，在 GitHub、GitLab、Bitbucket 这三个 Git 平台中选择一个进行连接，Vercel 会把 urepo 仓库复制到连接的平台上。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo/vercel_import_repo.png"
width="1204"
height="893"
loading="lazy"
alt="Vercel 导入仓库"
class="gallery-image"
data-flex-grow="134"
data-flex-basis="323px"
>&lt;/p>
&lt;p>接下来的 Create a Team 只要点击 Skip 跳过就行，然后就是环境变量的设置，urepo 会首先尝试从环境变量中读取这些私密信息，无法找到对应的信息时才会去读取项目根目录下的 auth.json 获取配置，与把访问令牌写在配置文件相比，利用环境变量配置可以避免自己不小心把私密信息公开，根据上文填写这五个环境变量后就完成部署了。&lt;/p>
&lt;h3 id="从本地上传部署">从本地上传部署
&lt;/h3>&lt;p>本方法需要安装 NodeJS 相关的工具链，我不太想和这些工具打交道，但 Vercel 本来是一个部署前端应用的平台，所以官方的客户端使用 JS 编写是很正常的事情，如果不想安装这些软件，那可以使用上面的部署方法。&lt;/p>
&lt;p>首先安装 Yarn 或其它 NodeJS 包管理器：&lt;code>pacman -S yarn&lt;/code>，由于 JS 应用总是喜欢在用户的家目录乱丢东西，所以为了让 Yarn 遵循&lt;a class="link" href="https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html" target="_blank" rel="noopener"
> XDG 目录规范&lt;/a>，我们可以执行 &lt;code>yarn config set prefix ~/.local&lt;/code>。然后执行下面的指令全局安装 vercel 应用，这会把它安装到你的家目录（~/.local/bin，记得让你的 $PATH 包含这个路径）：&lt;/p>
&lt;pre tabindex="0">&lt;code>yarn global add vercel
&lt;/code>&lt;/pre>&lt;p>安装完成后执行下面的指令进行登录，在打开的浏览器窗口注册或登录你的 Vercel 账号并进行验证：&lt;/p>
&lt;pre tabindex="0">&lt;code>vercel login
&lt;/code>&lt;/pre>&lt;p>下载 urepo 源码：&lt;/p>
&lt;pre tabindex="0">&lt;code>git clone git@github.com:vifly/urepo.git
&lt;/code>&lt;/pre>&lt;p>把 urepo 根目录下的 auth.json.example 重命名为 auth.json，然后把对应的配置填入里面。或者，也可以在上传部署后到 Vercel 的项目面板中设置 code、path、client_secret、client_id、refresh_token 这五个环境变量。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo/vercel_set_env.png"
width="1236"
height="902"
loading="lazy"
alt="Vercel 设置环境变量"
class="gallery-image"
data-flex-grow="137"
data-flex-basis="328px"
>&lt;/p>
&lt;p>最后就是上传部署：&lt;/p>
&lt;pre tabindex="0">&lt;code>cd urepo
vercel .
&lt;/code>&lt;/pre>&lt;h2 id="使用自己的域名可选">使用自己的域名（可选）
&lt;/h2>&lt;p>尽管 Vercel 会为部署的应用分配一个二级域名（xxx.vercel.app），但自建源使用自己的域名无疑是一个更好的选择。根据&lt;a class="link" href="https://vercel.com/docs/custom-domains#subdomains" target="_blank" rel="noopener"
>官方文档&lt;/a>，首先需要打开项目的域名管理界面，添加自己想使用的域名。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo/vercel_add_domain.png"
width="1319"
height="873"
loading="lazy"
alt="Vercel 添加域名"
class="gallery-image"
data-flex-grow="151"
data-flex-basis="362px"
>&lt;/p>
&lt;p>假设各位和我一样使用了自己的子域名，那么在自己的 DNS 解析服务提供商管理面板添加一条 CNAME 解析记录即可，我使用的是 cloudflare，还需要把代理状态设为“仅限 DNS”以确保不会使用 cloudflare 的反代。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo/cloudflare_set_vercel_cname.png"
width="1102"
height="154"
loading="lazy"
alt="在 cloudflare 设置指向 Vercel 的 CNAME"
class="gallery-image"
data-flex-grow="715"
data-flex-basis="1717px"
>&lt;/p>
&lt;h1 id="有待改进的地方">有待改进的地方
&lt;/h1>&lt;p>尽管这一流程已经能工作了，但有些地方还是可以再改进一下的。&lt;del>首先，目前并没有数字签名，添加这一自建软件源时需要禁用对此的签名校验，在乎安全性的同学可能会对此表示不爽，所以日后有必要加上对软件包签名的支持。其次，urepo 应该无需修改就可以用于分发其它发行版的软件包与数据库（它的本质就是一个简陋的 onedrive index），但前面的 GitHub Actions 只支持 Arch，我未来肯定会加上对 Debian/Ubuntu 的支持，具体什么时候搞定这个，就要看我什么时候有需求了，对其它发行版的支持也是同样的😂&lt;/del>。目前已支持 GPG 签名，也新增了 &lt;a class="link" href="https://github.com/vifly/debian-build" target="_blank" rel="noopener"
>debian-build&lt;/a> 用于构建 deb 软件包。&lt;/p>
&lt;p>另外，我编写的 urepo 与 GitHub Actions 脚本的报错信息并不够用户友好，由于大量采用了 Python 进行编写，假如出现错误的话对于没学过 Python 的同学来说可能难以根据输出的错误信息解决问题。这个问题也是留待日后解决。&lt;/p></description></item><item><title>GitHub Actions 打造 AUR 打包下载一条龙服务</title><link>https://viflythink.com/Use_GitHubActions_to_build_AUR/</link><pubDate>Tue, 28 Apr 2020 00:00:00 +0800</pubDate><guid>https://viflythink.com/Use_GitHubActions_to_build_AUR/</guid><description>&lt;img src="https://viflythink.com/Use_GitHubActions_to_build_AUR/show.png" alt="Featured image of post GitHub Actions 打造 AUR 打包下载一条龙服务" />&lt;p>&lt;em>2021.2.2.更新：受 &lt;a class="link" href="https://www.aloxaf.com/2020/06/build_aur_with_github_actions/" target="_blank" rel="noopener"
>Aloxaf 的博文&lt;/a>启发新增使用自己的 PKGBUILD 进行构建的说明。&lt;/em>&lt;/p>
&lt;p>尽管目前博主我还在考研，但最近还是经不住折腾 Arch 的诱惑，抽空对使用 Arch 以来一直觉得体验不够好的安装 AUR 软件包流程进行改造，最终的结果就是搭建了这一个自动化的 AUR 编译打包下载安装一条龙服务，并写下本文向各位安利。要问为什么我想折腾这个东西，当然是因为使用 AUR 助手安装 AUR 的软件包存在如下缺点：&lt;/p>
&lt;ol>
&lt;li>下载速度慢，由于很多时候都需要从 GitHub 下载文件，所以每秒 10 KB 的下载速度是很常见的（虽然这点可以通过设置 http_proxy 环境变量让 Yay 等 AUR 助手使用代理来解决）&lt;/li>
&lt;li>编译需要时间，如果你只是需要几个小软件包那可以无视这点&lt;/li>
&lt;li>给别人分享已打好的软件包有点麻烦，每次更新你都需要通过某种方式传输文件给对方（凑够三点 ／人◕‿‿◕人＼）&lt;/li>
&lt;/ol>
&lt;p>为了解决以上问题，本文使用免费的 GitHub Actions 与 Cloudflare Workers，手把手教你搭建一个自动化 AUR 软件构建流程，只需一次配置，你就可以享受船新的&lt;del>白嫖&lt;/del> AUR 使用体验。另外，这也是我第一次实际使用 CI（持续集成），通过配置整个工作流，我算是学习了一把 CI 的使用（&lt;em>PS：这才是真正的目的&lt;/em>），所以你也可以把这篇文章当作我的 CI 学习笔记。&lt;/p>
&lt;h1 id="github-actions-简介">GitHub Actions 简介
&lt;/h1>&lt;p>首先，GitHub Actions 是 GitHub 在 2019 年推出的一项 CI 服务。如果你没听说过 CI，那这里我尝试用一句话来解释，CI 就是对新的项目更改进行自动化构建，在本文的场景下，新的更改指的是 AUR 上的 PKGBUILD 文件发生变更（实际上我为了偷懒，选择了设置定时任务而不是监测 PKGBUILD 的变更），自动化构建就是自动编译加打包以及上传（如果是闭源软件那就不是编译而是拆包等操作）。嗯，就是这么简单，如果想知道 CI 的详细定义，可以看下&lt;a class="link" href="https://www.redhat.com/zh/topics/devops/what-is-ci-cd" target="_blank" rel="noopener"
>红帽的文章&lt;/a>。&lt;/p>
&lt;p>GitHub Actions 的特点是支持的触发条件种类数非常多，而且与 GitHub 的集成很好，学习难度也不高，只要简单地写一个配置文件即可，还可轻松调用别人写好的操作步骤，对于开源项目作者来说最大的好处就是可以白嫖 GitHub 的机器用来为不同的平台编译。如果你已经对 GitHub Actions 感到心动，那么不妨阅读&lt;a class="link" href="https://help.github.com/en/actions/getting-started-with-github-actions" target="_blank" rel="noopener"
>官方文档&lt;/a>来学习一下用法，或者靠&lt;a class="link" href="https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" target="_blank" rel="noopener"
>阮一峰的介绍文&lt;/a>快速上手。想要更简短的介绍？没问题，来看看下面的讲解吧。&lt;/p>
&lt;p>想要使用 GitHub Actions，那首先需要在项目根目录下的 .github/workflows 文件夹下创建一个以 yml 为后缀名的 workflow 文件（如 build.yml），在这个 YAML 文件中写入我们的配置。那么配置该怎么写呢，让我们看一个示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-YAML" data-lang="YAML">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Greeting from Mona&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">push&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">jobs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># ================== 第一个 job，这只有一个 job ==================&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">my-job&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">My Job&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">runs-on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ubuntu-latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">steps&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># ================== 第一个 step，执行单个命令 ==================&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Print a greeting&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">env&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">MY_VAR&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Hi there! My name is&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">FIRST_NAME&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Mona&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">MIDDLE_NAME&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">The&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">LAST_NAME&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Octocat&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># ================== 第二个 step，使用别人的 action ==================&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">actions/checkout@v2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># ================== 第三个 step，执行多个命令 ==================&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Install the dependencies&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">|&lt;/span>&lt;span class="sd">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="sd"> sudo apt-get update
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="sd"> sudo apt-get install pkg-config gettext&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>按从上到下的顺序来看，name 对象应该无需解释了，值得注意的是 &lt;a class="link" href="https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#on" target="_blank" rel="noopener"
>on&lt;/a> 对象，可以填入单个事件或事件数组作为触发条件，当满足条件时便执行这个 YAML 文件里的内容（一个项目可以存在多个 workflow 文件），在示例中的 push 指的是 git push，即每次推送代码都会触发这个 workflow，完整的事件支持列表可通过&lt;a class="link" href="https://help.github.com/en/articles/events-that-trigger-workflows" target="_blank" rel="noopener"
>官方文档&lt;/a>获知。&lt;/p>
&lt;p>接下来就是 jobs 了，在这里我们只创建了一个名为 my-job 的 job，一般而言 jobs 是 workflow 文件的主体，一个 job 由若干个 step 组成，这些 step 会按顺序执行，为了便于阅读，我用分割线将各个 step 分开了。&lt;/p>
&lt;p>在解释 step 前我们不妨先看下每一个 job 中都要填写的 &lt;a class="link" href="https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on" target="_blank" rel="noopener"
>runs-on&lt;/a> 对象，它指定了该 job 的工作系统环境，目前可选的系统有 windows-latest、ubuntu-latest、ubuntu-16.04、macos-latest，这覆盖了主流的操作系统平台，为不同平台的编译提供了便利。&lt;/p>
&lt;p>最后，就是每个 job 中必须存在的 step 了，每个 step 都代表一个单独的操作步骤，既可以在 &lt;a class="link" href="https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idstepsrun" target="_blank" rel="noopener"
>run&lt;/a> 对象内填入你需要执行的 Shell 命令，也可以在 &lt;a class="link" href="https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idstepsuses" target="_blank" rel="noopener"
>uses&lt;/a> 对象里填入对应的配置以使用别人的 action（在 &lt;a class="link" href="https://github.com/marketplace?type=actions" target="_blank" rel="noopener"
>Marketplace&lt;/a> 中浏览全部 action）。&lt;a class="link" href="https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idstepsenv" target="_blank" rel="noopener"
>env&lt;/a> 对象用来设置环境变量，这个对象存在一个非常有趣的应用场景：如果你的 step 需要使用不宜公开的 Token，那你可以&lt;a class="link" href="https://help.github.com/en/actions/configuring-and-managing-workflows/creating-and-storing-encrypted-secrets" target="_blank" rel="noopener"
>在项目设置中设置该 Token&lt;/a>，然后在 env 对象中使用 super_secret: $ 将这个 Token 设为一个环境变量，并在自己的 step 中读取该环境变量以取得 Token，这样就能避免在 workflow 文件中硬编码 Token。当你再次看到 $ 这样的变量时，你就应该明白这是一个私密变量，是不能公开的。&lt;/p>
&lt;h1 id="开始构造打包工作流">开始构造打包工作流
&lt;/h1>&lt;p>经过上文的介绍，各位应该对 GitHub Actions 有了一定的了解，接下来就让我们开始白嫖 GitHub Actions 吧。注意，本节中的说明均与最新版本的 &lt;a class="link" href="https://github.com/vifly/arch-build" target="_blank" rel="noopener"
>arch-build&lt;/a> 存在差异，仅用作描述思路，想要抄作业的请直接跳到“最终成品与配置”一节。&lt;/p>
&lt;h2 id="自动编译-aur-的软件包">自动编译 AUR 的软件包
&lt;/h2>&lt;p>一般而言，我们都是在 Arch Linux 上构建 AUR 上的软件包，但是上文提到的 runs-on 对象可以填入的系统并不包括 Arch，那该怎么办呢？答案是使用基于 Arch 的容器，在容器内构建。这里要感谢 &lt;a class="link" href="https://github.com/Qv2ray/Qv2ray" target="_blank" rel="noopener"
>Qv2ray&lt;/a> 的一位开发者 &lt;a class="link" href="https://www.ducksoft.site/" target="_blank" rel="noopener"
>DuckSoft&lt;/a> 提供了这个思路，而且编写了 &lt;a class="link" href="https://github.com/DuckSoft/build-aur-action" target="_blank" rel="noopener"
>build-aur-action&lt;/a> 这个 action 用来编译打包 AUR 上的软件。现在，我们需要考虑的就是如何自动进行编译，从 CI 的正常使用方式来说，我们应该在 on 对象中设定这样一个触发条件：当 AUR 特定的软件包更新时自动进行编译。不过这个方案还需要写检测更新的代码，为了偷懒，我选择设置定时任务来编译，由于 on 对象支持&lt;a class="link" href="https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#onschedule" target="_blank" rel="noopener"
>通过 Cron 语法设定定时任务&lt;/a>，所以这个问题能被轻松解决。就这样，我们完成了一个简单的 workflow 文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-YAML" data-lang="YAML">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">BUILD&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">schedule&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">cron&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;1 */8 * * *&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">jobs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">build&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">runs-on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ubuntu-latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">steps&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">DuckSoft/build-aur-action@master&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">repo-name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">osu-lazer&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>提醒一下，使用别人的 action 时可能需要使用 with 对象输入一些变量，在这里我们输入的就是想要构建的 AUR 软件的软件包名。&lt;/p>
&lt;h2 id="上传到-github-releases">上传到 GitHub Releases
&lt;/h2>&lt;p>在上一步中我们已成功地构建了想要的软件包，接下来需要解决的就是如何把软件包取出来这个问题了。最好的解决方案莫过于将构建出来的软件包上传到 Releases，GitHub 官方提供了 &lt;a class="link" href="https://github.com/actions/upload-release-asset" target="_blank" rel="noopener"
>upload-release-asset&lt;/a> 来完成这个操作，但我看了说明文档后觉得这个太麻烦了，它不支持通过 Unix 终端规则（例如 “*.zst”）筛选要上传的文件，而且需要先创建 Releases 后才能上传文件。经过一番谷歌，我找到了 &lt;a class="link" href="https://github.com/ncipollo/release-action" target="_blank" rel="noopener"
>release-action&lt;/a> 这个替代品，与 upload-release-asset 相比，这个 action 的配置明显更简单，从下面这段配置即可看得出来：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-YAML" data-lang="YAML">&lt;span class="line">&lt;span class="cl">- &lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ncipollo/release-action@v1.7.3&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">allowUpdates&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">tag&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;packages&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">artifacts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;./*/*.zst&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">token&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${{ secrets.GITHUB_TOKEN }}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>把这段配置添加到 workflow 中，然后我们先看看 with 对象中输入的变量。token 是上传文件到 Releases 时必需的一项变量，从它的形式就可以看出这是一个私密变量，不过这个私密变量是内置的，我们不需要在项目中手动设置这个变量，直接使用即可；接着就是 tag 了，为了方便管理，我们在仓库的 Releases 页面创建一个 tag，然后将 tag 的名字填入其中。完成配置后这个 action 就会把构建的软件包上传到指定 tag 下的 Releases，我们也可以下载该软件包了。&lt;/p>
&lt;h2 id="使用-matrix-进行改进">使用 matrix 进行改进
&lt;/h2>&lt;p>虽然目前我们的 workflow 已经能用了，但是需要编译多个 AUR 的软件时需要多次复制粘贴上面的 step，这可太难看了，是否存在更优雅的方法呢？答案是有的，经 DuckSoft 的提醒，可以使用 &lt;a class="link" href="https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idstrategymatrix" target="_blank" rel="noopener"
>matrix&lt;/a>，它基于单个 job 中定义的 steps 并行运行多个 job，多个 job 之间的差异就是特定变量的差异，这些变量以数组的形式存在。一般来说，matrix 的用处就是为不同平台采取同样的步骤进行构建，在本文的场景下就是采用同样的步骤构建不同的 AUR 软件。虽然听着有点抽象，但看一下这个例子你就应该能明白了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-YAML" data-lang="YAML">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">jobs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">build&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">strategy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">matrix&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">repos&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="l">osu-lazer, mpv-mpris]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">fail-fast&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">runs-on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ubuntu-latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">steps&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">DuckSoft/build-aur-action@master&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">repo-name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${{ matrix.repos }}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>与之前的 workflow 不同，我们先创建了 repos 数组，并在其中填入需要构建的软件名。如果不把 fail-fast 设置为 false，在并行 job 中出现一个运行失败的 job 时会导致其它的 job 被终止。另外，使用 build-aur-action 时我们没有直接输入 repo-name，而是以 $ 的形式输入，数组中的变量会自动应用到对应的 job 中。&lt;/p>
&lt;h2 id="使用自己的-pkgbuild可选">使用自己的 PKGBUILD（可选）
&lt;/h2>&lt;p>上述版本已经很完美了，不过还存在一个问题：我需要的某个软件包虽然在 AUR 中存在，但对应的 PKGBUILD 写的太烂了/无法构建成功，此时我写了一个 PKGBUILD，希望能白嫖 GitHub Actions 进行构建，该怎么办呢。这个需求也是早有人想到了，只需使用 &lt;a class="link" href="https://github.com/edlanglois/pkgbuild-action" target="_blank" rel="noopener"
>pkgbuild-action&lt;/a> 就可解决，它还可以解决打的包还依赖了其它的 AUR 包的问题。为此，我们需要再添加一个 job，checkout 目前仓库获取 PKGBUILD，然后使用 pkgbuild-action 进行构建，需要的 pkgdir 参数就是 PKGBUILD 所在的路径（父文件夹），最后依然是使用 release-action 根据 pkgbuild-action 返回的构建产物路径将其上传到 GitHub Releases。&lt;/p>
&lt;h1 id="最终成品与配置">最终成品与配置
&lt;/h1>&lt;p>最终版的 workflow 可以在&lt;a class="link" href="https://github.com/vifly/arch-build/blob/master/.github/workflows/build.yml" target="_blank" rel="noopener"
>这&lt;/a>查看，只需 fork &lt;a class="link" href="https://github.com/vifly/arch-build" target="_blank" rel="noopener"
>arch-build&lt;/a>，然后按下面的说明修改一下 workflow 文件即可食用。注意，经过一段时间的改进，最终版的配置已与上文存在一定区别，其中的 uploadToOneDrive 是&lt;a class="link" href="https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo" target="_blank" rel="noopener"
>《使用 Vercel 与 OneDrive 自建软件源》&lt;/a>中所需的 job，如果你不需要建立一个可公共访问的软件源请删掉它。&lt;/p>
&lt;p>如果只是需要构建上传 AUR 包，那只需修改 buildAUR 这个 job 中的内容，根据自己的需要修改其 matrix 内的软件包名，buildNonAUR 的内容则可以删掉。&lt;/p>
&lt;p>如果想使用自己的 PKGBUILD 进行构建，那还需要修改 buildNonAUR 这个 job，依然需要修改其 matrix 内的软件包名，另外还需要在仓库的根目录下新建以软件包名命名的文件夹，在其中存放对应的 PKGBUILD 文件和其它构建过程中所需的资源文件。经过我的修改后的 pkgbuild-action 还支持一个新功能：如果想构建的软件包依赖某个 AUR 软件包而你不想使用 AUR 上的 PKGBUILD，那么你可以新建一个子文件夹，在其中放入自己的 PKGBUILD。结构如下所示：&lt;/p>
&lt;pre tabindex="0">&lt;code>├── foo
│   ├── PKGBUILD
│   └── bar (dependences of foo)
│   ├── PKGBUILD
│   └── baz (dependences of bar)
│   └── PKGBUILD
&lt;/code>&lt;/pre>&lt;p>到此为止，借助 GitHub Actions，我们拥有了一个 24 小时可用的编译机以及公开的软件包存储库，解决了本文开始提到的第二与第三点问题。这些都是全自动且免费的，为了更好的体验，下文将介绍如何让安装软件包也实现自动化。&lt;/p>
&lt;h1 id="简单的自动更新仓库">简单的自动更新仓库
&lt;/h1>&lt;p>打开浏览器，从 Releases 页面下载软件包，然后执行 pacman -U xxx.pkg.tar.zst 安装软件包，这些操作实在太麻烦了，为何不建立一个软件源，令每次执行 pacman -Syu 时自动安装最新版本的软件呢。自建软件源听上去十分高大上，但其实只是建立一个本地软件源并不难，&lt;a class="link" href="https://wiki.archlinux.org/index.php/Pacman/Tips_and_tricks#Custom_local_repository" target="_blank" rel="noopener"
>Arch WiKi 几段文字&lt;/a>便说明白了，当然，如果想建立一个在线的公用软件源会麻烦一些，所以这里只说明如何建立一个自动更新的本地软件源。想要建立公用软件源的话请跳过下文，阅读我的新博文&lt;a class="link" href="https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo" target="_blank" rel="noopener"
>《使用 Vercel 与 OneDrive 自建软件源》&lt;/a>。&lt;/p>
&lt;h2 id="使用自动化脚本">使用自动化脚本
&lt;/h2>&lt;p>作为一个爱偷懒的人，我肯定希望能自动化下载软件包与更新软件仓库的操作，为此我写了一个脚本来完成这些事情，各位只需打开&lt;a class="link" href="https://github.com/vifly/helper" target="_blank" rel="noopener"
>项目地址&lt;/a>，下载代码并根据说明进行操作即可。我在这里说明一下 conf.py 的配置：UserName 和 GitHubRepoName 并不难理解，举个例子，我的白嫖仓库地址是 &lt;a class="link" href="https://github.com/vifly/arch-build" target="_blank" rel="noopener"
>https://github.com/vifly/arch-build&lt;/a> ，那么需要填写的 UserName 便是 vifly，GitHubRepoName 则是 arch-build；ProxyURL 在下一小节会提到，这里先不说；DownloadPath 是从 Releases 下载的软件包的存储路径；末尾的 ArchRepoDBPath 和 ArchRepoName 是用于生成本地软件源的数据库的，脚本会调用 repo-add 根据 DownloadPath 中的软件包生成路径为 ArchRepoDBPath/ArchRepoName.db.tar.gz 的数据库。&lt;br>
当你成功运行脚本建立了一个本地软件源后，还需要修改 /etc/pacman.conf 文件，在末尾添加以下配置以让 Pacman 同步你的软件源的数据库（自行替换 ArchRepoName 与 ArchRepoDBPath）：&lt;/p>
&lt;pre>&lt;code>[ArchRepoName]
SigLevel = Optional TrustAll
Server = file://ArchRepoDBPath
&lt;/code>&lt;/pre>
&lt;p>另外，为了让本地的软件仓库保持最新，我们可以通过 &lt;a class="link" href="https://wiki.archlinux.org/index.php/cron" target="_blank" rel="noopener"
>Cron&lt;/a> 设置一个定时任务自动运行这个脚本。现在，我们得到了一个完全免费、自动更新的个人软件仓库，快执行 pacman -Syu 开始享受白嫖的快乐吧。&lt;/p>
&lt;h2 id="使用-cloudflare-workers-反代加速下载可选">使用 Cloudflare Workers 反代加速下载（可选）
&lt;/h2>&lt;p>为了解决在国内 GitHub 下载速度慢的问题，让我们继续发扬白嫖的精神，使用 &lt;a class="link" href="https://workers.cloudflare.com/" target="_blank" rel="noopener"
>Cloudflare Workers&lt;/a>（不需要拥有域名） 来加快下载速度。广大白嫖党早已发现可以使用免费的 Cloudflare Workers 部署 serverless 应用反代国内无法访问的网络资源，在这里我们也使用这种方式加速下载。刚开始时我使用了 &lt;a class="link" href="https://github.com/hunshcn/gh-proxy" target="_blank" rel="noopener"
>gh-proxy&lt;/a> 这个加速 GitHub 下载的项目，不过后来 Arch 群的 &lt;a class="link" href="https://nichi.co/" target="_blank" rel="noopener"
>NickCao&lt;/a> 同学推荐了他写的更通用的反代应用，感谢 NickCao，接下来我们便开始部署反代应用吧。 &lt;br>
首先，打开&lt;a class="link" href="https://workers.cloudflare.com/" target="_blank" rel="noopener"
>官网&lt;/a>，注册或登录你的 Cloudflare 帐号，点击 Start building，选择免费方案并创建一个专属的子域名（是 workers.dev 的子域名），进入主页后点击 Create a Worker，复制&lt;a class="link" href="https://gitlab.com/NickCao/experiments/-/blob/master/workers/r.js" target="_blank" rel="noopener"
>这份代码&lt;/a>，像下图这样粘贴到编辑框内：&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Use_GitHubActions_to_build_AUR/create_cloudflare_workers.png"
width="1918"
height="835"
loading="lazy"
alt="创建 Cloudflare Workers 应用"
class="gallery-image"
data-flex-grow="229"
data-flex-basis="551px"
>&lt;/p>
&lt;p>注意，页面中间的域名是 Cloudflare Workers 分配给你的一个专属子域名（形如 xxx.xxx.workers.dev），复制这个域名并用它替换左侧代码中的两处域名，完成修改后点击 Save and Deploy 保存并部署，这样我们就得到了一个可以反代网络资源的应用了。&lt;/p>
&lt;p>最后，还记得在上一小节中被忽略的 ProxyURL 配置项吗，这里各位只需填入刚刚得到的 xxx.xxx.workers.dev 域名就可以了，脚本会使用这个反代域名高速下载 GitHub Releases 的软件包。&lt;/p></description></item><item><title>将 KDE 改造为 Windows 10</title><link>https://viflythink.com/KDE_to_Windows10/</link><pubDate>Wed, 01 Jan 2020 10:08:32 +0800</pubDate><guid>https://viflythink.com/KDE_to_Windows10/</guid><description>&lt;img src="https://viflythink.com/KDE_to_Windows10/show.jpg" alt="Featured image of post 将 KDE 改造为 Windows 10" />&lt;p>&lt;em>2023.6.18.更新：为适配新版本的 KDE 以及找到了更好的方案，本文大部分内容已被更新。注意旧的一些配图依然有所保留，所以不要对截图风格不统一感到奇怪。&lt;/em>&lt;/p>
&lt;p>2020 年已然到来，一些博主已经发表了年度总结，总结了不少经验，我想了想，觉得自己好像没什么可以总结的经验，只好写一篇最近的 KDE 折腾记录给各位读者当新年礼物了。想必有不少刚开始使用 Linux 的新手总想着美化自己的桌面吧，我在开始使用 KDE 后也想着折腾美化，随便搜索了一下美化教程后发现不少都是将 KDE 改造为 Mac 风格的，之前听闻 KDE 粉说过“你可以将 KDE 捏成任何形状”，然而很多人都是将它捏成 Mac 的样子，那么，能把 KDE 捏成 win10 的形状吗？我决定挑战一下这个问题，当然，在这里我要承认这有点标题党的嫌疑，我只是想将我认为 win10 做得好的部分转嫁到 KDE 上，并不是将 KDE 完全变为 win10 的样子，后者是一件费力不讨好的事情，而且，在经过一波折腾后，我发现有些细节还暂时无法做到像 win10 那样优秀，只能寄希望于未来了。另外，本文只适用于 Arch，我尚未在其它发行版进行测试。&lt;/p>
&lt;p>先上一张图片看看改造后的效果（图中标注了下文用到的名词所指代的东西）：&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/KDE_to_Windows10/my_kde_desktop.png"
width="1920"
height="1080"
loading="lazy"
alt="我的桌面展示"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="426px"
>&lt;/p>
&lt;p>觉得很漂亮吧？那么，接下来就开始我们的改造吧。&lt;/p>
&lt;h1 id="底部栏">底部栏
&lt;/h1>&lt;p>在没有打开任何窗口时，底部栏是与 win10 相差最远的一个地方，所以我们的改造工作先从底部栏开始。可以先看看改造完成后的底部栏效果图：&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/KDE_to_Windows10/my_bottom.png"
width="2558"
height="52"
loading="lazy"
alt="底部栏"
class="gallery-image"
data-flex-grow="4919"
data-flex-basis="11806px"
>&lt;/p>
&lt;h2 id="开始菜单">开始菜单
&lt;/h2>&lt;p>喜欢 win10 那简洁的开始菜单吗，在 KDE 下只需安装一个挂件（widgets）即可拥有同样的体验。下载 &lt;a class="link" href="https://store.kde.org/p/1160672/" target="_blank" rel="noopener"
>Tiled Menu&lt;/a>，并在底部栏空白处单击右键，然后点击“添加挂件”，按照下图所示进行安装。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/KDE_to_Windows10/install_widget.png"
width="288"
height="880"
loading="lazy"
alt="安装挂件"
class="gallery-image"
data-flex-grow="32"
data-flex-basis="78px"
>&lt;/p>
&lt;p>想要使用的话有两种方法：在你左下角的开始菜单处鼠标右键单击，选择“显示替代方案”，选择 Tiled Menu；在底部栏右键单击，选择“编辑面板”，鼠标移到原来的开始菜单，选择移除，然后选择“添加挂件”，选择 Tiled Menu。你可以在弹出的开始菜单右上角按住 ALT 和 鼠标右键进行拖拽以更改菜单大小。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/KDE_to_Windows10/set_start_menu.png"
width="1920"
height="232"
loading="lazy"
alt="将 Tiled Menu 设为开始菜单"
class="gallery-image"
data-flex-grow="827"
data-flex-basis="1986px"
>&lt;/p>
&lt;h2 id="任务管理器挂件">任务管理器挂件
&lt;/h2>&lt;p>依然是在底部栏右键单击，选择“编辑面板”，将鼠标移动到底部栏空白处，点击“显示替代方案”，选择图标任务管理器（Icon-Only Task Manager），然后你就可以看到类似于 win10 的底部窗口了，这里说明一下，图标任务管理器是自带的一个挂件，无需安装。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/KDE_to_Windows10/set_task_manager.png"
width="1920"
height="250"
loading="lazy"
alt="设置图标任务管理器"
class="gallery-image"
data-flex-grow="768"
data-flex-basis="1843px"
>&lt;/p>
&lt;h2 id="快速查看已打开的窗口">快速查看已打开的窗口
&lt;/h2>&lt;p>win10 可点击左下角的按钮快速查看已打开的窗口，在安装了 &lt;a class="link" href="https://store.kde.org/p/1181039" target="_blank" rel="noopener"
>Present Windows Button&lt;/a> 这个挂件后，我们也可以做到这一点。这个挂件的安装方法与 Tiled Menu 时相同，在安装完成后把这个挂件放在开始菜单和任务管理器之间。这个挂件产生的点击效果与在 Gnome 下将鼠标移动到屏幕左上角触发的效果差不多，KDE 也可设置这样的触发角，不过我觉得设置这样的一个按钮没什么实际意义，可能最大的好处就是没事点一下能有效消遣无聊吧（雾）。这里还有一个能让底部栏变得更美观的 Tips，在底部栏右键单击，选择“编辑面板”后点击“添加间距”，以此添加两个间距，将其缩到最小后对其右键取消勾选“设置可变大小”，根据实际情况可能还需要把间距的空隔宽度设为非零值，然后将这两个间距拖到 Present Windows Button 两边，这能令 Present Windows Button 两边不会显得拥挤，从而变得美观。&lt;/p>
&lt;h2 id="其它">其它
&lt;/h2>&lt;p>我知道存在 &lt;a class="link" href="https://store.kde.org/p/1167558/" target="_blank" rel="noopener"
>Winux10&lt;/a> 之类的图标主题可以将默认的图标替换为 win10 图标，但我经过尝试后发现其覆盖不全面，用以截图假装自己在使用 win10 是可以的，但日常使用会感到违和，所以还是推荐使用默认的图标主题。还有一个细节，那就是右下角的时钟，想让它像 win10 那样双栏显示日期和时间并不难：在底部栏空白处右键单击，选择“编辑面板”，编辑“面板高度”的值，稍微调高一些后，右键单击时钟，选择“配置数字时钟”，勾选“显示日期”，并将时间显示改为24小时制。&lt;/p>
&lt;h1 id="样式大改">样式大改
&lt;/h1>&lt;h2 id="桌面整体样式">桌面整体样式
&lt;/h2>&lt;p>仅仅只是桌面布局接近 win10 是不够的，还有相当一部分的桌面细节可以继续改进。这一部分主要是对桌面面板的图标以及挂件的样式进行修改，基于 &lt;a class="link" href="https://github.com/vinceliuice/Fluent-kde" target="_blank" rel="noopener"
>Fluent-kde&lt;/a> 这一项目来实现。Fluent-kde 包含了应用于各个方面的 Fluent 风格主题，由于我不打算折腾 Kvantum，所以仅使用其提供的 Plasma Desktop Themes。克隆 Fluent-kde 到本地后，进入项目目录并运行：&lt;/p>
&lt;pre>&lt;code>cp -r ./plasma/desktoptheme/* ~/.local/share/plasma/desktoptheme
&lt;/code>&lt;/pre>
&lt;p>然后就可以在系统设置中的“外观”-&amp;gt;“Plasma 视觉风格”中找到新增加的几个主题了，选择自己喜欢的 Fluent 风格主题并点击“应用”即可。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/KDE_to_Windows10/set_plasma_desktop_themes.png"
width="1465"
height="1024"
loading="lazy"
alt="设置 Plasma 视觉风格"
class="gallery-image"
data-flex-grow="143"
data-flex-basis="343px"
>&lt;/p>
&lt;h2 id="应用程序内部风格">应用程序内部风格
&lt;/h2>&lt;p>经过上面的折腾后，桌面截图已经足够接近 win10 了，但一旦随便打开一个应用就会露馅，所以需要也让应用程序的风格向 win10 靠拢。首先我们需要安装 &lt;a class="link" href="https://github.com/Luwx/Lightly" target="_blank" rel="noopener"
>Lightly&lt;/a> 主题，该主题虽然并非完全向 Fluent 靠拢，但也足够现代。由于目前其并不在积极维护状态，所以仅在 AUR 上有 PKGBUILD，可以在终端输入指令安装（需要安装 Yay 这个 AUR 助手）：&lt;/p>
&lt;pre>&lt;code>yay -S lightly-git
&lt;/code>&lt;/pre>
&lt;p>在安装完成后重启系统，打开系统设置，在侧栏点击“外观”，再点击“应用程序风格”，选择“Lightly”并应用更改；此外为还建议点击那个笔状的图标调整这个主题，把透明度改为下图中的数值。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/KDE_to_Windows10/use_lightly.png"
width="1467"
height="1026"
loading="lazy"
alt="应用 Lightly 主题"
class="gallery-image"
data-flex-grow="142"
data-flex-basis="343px"
>&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/KDE_to_Windows10/set_lightly_transparency.png"
width="731"
height="649"
loading="lazy"
alt="设置 Lightly 透明度"
class="gallery-image"
data-flex-grow="112"
data-flex-basis="270px"
>&lt;/p>
&lt;p>完成上面的操作随便打开一个 Qt 应用（如 Dolphin）都会发现其风格变得与 win10 应用很像，但 GTK 应用（如我使用的 lollypop）依然死性不改，原因就在于 GTK 应用与 Qt 应用所采用的主题是不一样的，为此我们需要安装同一个作者出品的 &lt;a class="link" href="https://www.gnome-look.org/p/1574551" target="_blank" rel="noopener"
>Fluent round gtk theme&lt;/a>。打开该主题页面后选择并下载一个自己喜欢的 Fluent 主题，然后将其解压到 ~/.themes 下（如该路径不存在则自行创建），重回刚才设置应用程序风格的界面，点击“配置 GNOME/GTK 应用程序风格”，选择刚安装的主题并点击“应用”。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/KDE_to_Windows10/set_gtk_app_theme.png"
width="1465"
height="1025"
loading="lazy"
alt="设置 GTK 应用风格"
class="gallery-image"
data-flex-grow="142"
data-flex-basis="343px"
>&lt;/p>
&lt;p>此时可以看到 lollypop 的风格也向 win10 靠拢了。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/KDE_to_Windows10/lollypop.png"
width="1299"
height="957"
loading="lazy"
alt="lollypop"
class="gallery-image"
data-flex-grow="135"
data-flex-basis="325px"
>&lt;/p>
&lt;h2 id="窗口装饰">窗口装饰
&lt;/h2>&lt;p>KDE 的窗口装饰指的是打开的应用程序窗口的顶部部分（就是包含了最小化、最大化、关闭按钮的那一栏）。我在 Google 搜索如何让 KDE 变得像 win10 时发现了一个非常新的 KDE 主题 &lt;a class="link" href="https://github.com/fauzie811/Breeze10" target="_blank" rel="noopener"
>Breeze10&lt;/a>，从 Github 页面上的图片可以看出这个主题可以完美地将窗口装饰变为 win10 的风格。&lt;del>由于目前（2019年12月）还没人打包，所以需要按照其 Github 页面上的操作步骤进行编译安装&lt;/del>。AUR 上已有 PKGBUILD，所以我们可以在终端输入指令安装（需要 Yay）：&lt;/p>
&lt;pre>&lt;code>yay -S breeze10-kde-git
&lt;/code>&lt;/pre>
&lt;p>此外，我的&lt;a class="link" href="https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo/" target="_blank" rel="noopener"
>个人源&lt;/a>里也有该软件包，可以&lt;a class="link" href="https://viflythink.com/service/#arch-%E8%BD%AF%E4%BB%B6%E6%BA%90" target="_blank" rel="noopener"
>添加我的 Arch 软件源&lt;/a>后安装：&lt;/p>
&lt;pre>&lt;code>pacman -S breeze10-kde-git
&lt;/code>&lt;/pre>
&lt;p>在安装完成后重启系统，打开系统设置，在侧栏点击“外观”，再点击“窗口装饰元素”，选择“Breeze10”并应用更改；此外还可以点击那个笔状的图标调整这个主题，例如把字体设置变大，完成后你的应用程序窗口会显得更为美观大方。最后，把“窗口边框大小”设为“无边框”。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/KDE_to_Windows10/set_breeze10.png"
width="1462"
height="1027"
loading="lazy"
alt="使用 Breeze10"
class="gallery-image"
data-flex-grow="142"
data-flex-basis="341px"
>&lt;/p>
&lt;h1 id="其它细节">其它细节
&lt;/h1>&lt;p>当你习惯性地用 ALT + TAB 键想要切换窗口时，就会发现在默认设置的情况下窗口列表将在左侧显示，我个人更喜欢 win10 或 Gnome 那样在切换窗口将列表显示在屏幕中间，为了做到这一点，打开系统设置，在侧栏点击“窗口管理”，然后点击“任务切换器”，在“可视化”处选择大图标，可看下图：&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/KDE_to_Windows10/set_task_switch.png"
width="1093"
height="754"
loading="lazy"
alt="设置任务切换器"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="347px"
>&lt;/p>
&lt;p>我并不喜欢每次点击关机按钮后都要进行确认，而是希望像 win10 那样直接关机，这也是稍微修改系统设置即可做到的事情，打开系统设置，在侧栏点击“开机和关机”，然后点击“桌面会话”，取消勾选“注销屏幕”一栏的“显示”。&lt;/p>
&lt;h1 id="总结">总结
&lt;/h1>&lt;p>经过这么多的折腾后，我总算是大概了解 KDE 了，“你可以将 KDE 捏成任何形状”毕竟只是一句用来吹嘘的话，除非动手改源代码，否则可自定义的部分总是有极限的，例如，在完成上述改造后，我对图标任务管理器并不完全满意，因为其显示的程序图标还是偏大，导致图标之间的间距不足，无法模拟 win10 底部栏的美观大方的感觉，当然，还有其它地方的间距设置也不尽人意，这些都难以通过安装主题等手段进行改造。当然，我个人认为没必要为此下结论说开源项目都处于美工下线的状态，其实无论是 KDE，亦或是 Gnome，它们的整体外观水平已经是与 Windows、Mac 这些商业公司开发的系统持平了，Linux 用户同样能有不差的桌面体验，KDE 等桌面所欠缺的只是一些审美细节，由于我也不懂设计，这里就不多说了。如果有兴趣的话，还可以多翻翻系统设置里的选项，其中包含了大量与桌面相关的自定义选项，这已经提供了非常大的改造空间。最后，在新的一年里，祝各位折腾愉快。&lt;/p></description></item><item><title>从 Debian 迁移到 Arch Linux</title><link>https://viflythink.com/Try_Arch_Linux/</link><pubDate>Sun, 03 Nov 2019 14:34:27 +0800</pubDate><guid>https://viflythink.com/Try_Arch_Linux/</guid><description>&lt;img src="https://viflythink.com/Try_Arch_Linux/show.jpg" alt="Featured image of post 从 Debian 迁移到 Arch Linux" />&lt;p>&lt;em>2023.8.8.更新：写了一篇&lt;a class="link" href="https://viflythink.com/New-Install-Arch/" target="_blank" rel="noopener"
>新 Arch 的安装随手记&lt;/a>，推荐与本文对比阅读。&lt;/em>&lt;/p>
&lt;p>在用了将近两年的 Debian 后，我打算尝试另一个与 Debian 存在较大差别的发行版，做了一番比较后（&lt;del>并没有&lt;/del>）选择了相比 Debian 激进许多（经常需要滚包）的 Arch Linux。其实我在刚开始使用 Debian 时便听说过 Arch Linux 了，这都要归功于活跃的&lt;a class="link" href="https://www.archlinuxcn.org/" target="_blank" rel="noopener"
> Arch Linux 中文社区&lt;/a>，里面的人整天忙着安利 Arch Linux（&lt;del>传教&lt;/del>），而且，&lt;a class="link" href="https://wiki.archlinux.org/index.php/Main_page_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29" target="_blank" rel="noopener"
> Arch Linux 的 Wiki &lt;/a>也是非常优秀的文档，我在 Debian 上遇到问题时也会参考 Arch Linux 的 Wiki，久而久之，便产生了尝试 Arch Linux 的想法，此外，对于现在的我而言，&lt;a class="link" href="https://wiki.archlinux.org/index.php/Arch_Linux_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#%E5%8E%9F%E5%88%99" target="_blank" rel="noopener"
>Arch Linux 的哲学&lt;/a>也非常有意思，其中提到：&lt;/p>
&lt;blockquote>
&lt;p>Arch 适用于乐于自己动手的用户，他们愿意花时间阅读文档，解决自己的问题。&lt;/p>
&lt;/blockquote>
&lt;p>这完全符合我想折腾 Linux 的想法！当然，我认为 Arch Linux 对 Linux 新手来说并不合适，因为光是第一步的使用命令行安装系统（Arch Linux 官方没有提供图形化安装界面）恐怕就能劝退不少人了，不过对于接触过 Linux 的人，通过理解 Arch Linux 安装过程中所需要输入的指令的含义，能体会到一种完全掌握自己的系统的快感（&lt;del>误入邪教&lt;/del>）。总而言之，对于喜欢折腾的人来说，尝试 Arch Linux 是绝对不会后悔的决定。&lt;/p>
&lt;p>由于 Arch Linux 的激进策略，安装教程很容易过时，我也不打算费力不讨好地写具体的安装步骤了，本文主要分享我在 Arch Linux 下使用的软件，希望能安利更多人使用（提到的不少软件都是跨平台的，即使不使用 Arch Linux 也可使用这些软件）。先在这里说一下我挑选软件的原则：通用性是最重要的，无论在哪个平台上使用都具有近乎一致的体验，为此没有利用单个平台的特性也是可接受的；数据可无障碍导出与导入，尊重用户的选择自由；简单易用且具备可扩展性（例如可安装扩展增强功能），但我也不排斥“一次配置，终身受用”这样需要折腾的软件；当然，开源是最好的。能达到这些要求的软件实属少数派，我在下文仅仅推荐几个，有空再补充。&lt;/p>
&lt;h1 id="安装">安装
&lt;/h1>&lt;p>考虑到 Arch Linux 经常变动，所以最好的安装指南应该是官方的&lt;a class="link" href="https://wiki.archlinux.org/index.php/Installation_guide" target="_blank" rel="noopener"
> Installation Guide&lt;/a>，我另外也参考了两篇博文，一个是萌狼的&lt;a class="link" href="https://blog.yoitsu.moe/arch-linux/installing_arch_linux_for_complete_newbies.html" target="_blank" rel="noopener"
>给 GNU/Linux 萌新的 Arch Linux 安装指南 rev.B&lt;/a>，另一个是&lt;a class="link" href="https://www.viseator.com/2017/05/17/arch_install/" target="_blank" rel="noopener"
>以官方Wiki的方式安装ArchLinux&lt;/a>。对于我这样存在多系统的情况，执行了 grub-mkconfig 后最好检查一下/boot/grub/grub.cfg 是否包括了所有的系统。 &lt;br>
有关于桌面环境的选择，鉴于之前总是看到各位大佬吹 Arch Linux 的 KDE 桌面的美观，而我一直在 Debian 下使用 Gnome，这回便决定尝试 KDE（&lt;del>其实是为了在出问题时更容易找到大佬求救&lt;/del>），在安装了 kde-applications 后，开始嫌弃如此多的用不上的应用了（说的就是教育与游戏分类下的那堆东西），所以花了点时间写了一个&lt;a class="link" href="https://gist.github.com/vifly/33d1a4f63b0b7319c6db9af9d3bdbdb0" target="_blank" rel="noopener"
>简单的 Python 脚本&lt;/a>删除这些软件（&lt;strong>需要 root 权限，使用需谨慎&lt;/strong>）。安装完成后重启进入桌面，我不得不表示默认的 KDE 桌面比 Gnome 漂亮多了，相比之下，Gnome 的塑料风格看着实在是让我难受。另外，KDE 全家桶之间的配合也令我十分满意，统一的设计风格，美观的特效，让我忍不住想吹爆 KDE 了。有一个值得一提的细节，在 KDE 下的鼠标单击等于其它桌面环境下的鼠标双击（例如在其它桌面环境下打开文件需要双击），一开始我并不习惯这种设置，觉得不便于选中单个文件，但用多了以后发现这种操作明显更轻松，因为平常使用鼠标时双击的频率比单击要高，而双击肯定比单击累，将双击替换为单击肯定可以减缓疲劳，对于需要选中单个文件的情况，右键也能满足需求，这又成了一个我喜欢 KDE 的原因。&lt;br>
除了桌面环境外，首先需要熟悉的还有 Arch Linux 的软件包管理器 Pacman，它的命令行参数与 apt 完全不一样，开始使用时经常需要查看其&lt;a class="link" href="https://wiki.archlinux.org/index.php/Pacman" target="_blank" rel="noopener"
> Wiki 页面&lt;/a>，值得一提的是，得益于&lt;a class="link" href="https://wiki.archlinux.org/index.php/Arch_User_Repository" target="_blank" rel="noopener"
> AUR(Arch User Repository) &lt;/a>的存在以及 Arch Linux 打包的低门槛，Arch Linux 拥有数量庞大的软件包，考虑到可能会使用 AUR 里的软件包，所以我安装了&lt;a class="link" href="https://github.com/Jguer/yay" target="_blank" rel="noopener"
> Yay &lt;/a>这个&lt;a class="link" href="https://wiki.archlinux.org/index.php/AUR_helpers" target="_blank" rel="noopener"
> AUR 助手&lt;/a>（Yay 完全兼容 Pacman 的命令行参数）帮我节省输入 makepkg 等指令的步骤，下文涉及到安装软件的指令既有可能使用 Pacman，也有可能使用 Yay。&lt;/p>
&lt;h1 id="中国大陆用户所需的东西">中国大陆用户所需的东西
&lt;/h1>&lt;h2 id="中文设置">中文设置
&lt;/h2>&lt;p>我直接根据&lt;a class="link" href="https://szclsya.me/zh-cn/posts/fonts/linux-config-guide/" target="_blank" rel="noopener"
> Linux 下的字体调校指南&lt;/a>一文进行调教，在这里我想说一下该博文中提到的“archlinuxcn required”，这意味着需要&lt;a class="link" href="https://www.archlinuxcn.org/archlinux-cn-repo-and-mirror/" target="_blank" rel="noopener"
>添加 archlinuxcn 源&lt;/a>，上面介绍已经提到了 Arch Linux 中文社区，而这个社区维护着一个非官方软件仓库，被称为 Arch Linux 中文社区仓库（archlinuxcn 源），该仓库包括了很多中文用户会用到的已编译好的软件包，而 AUR 提供的是 PKGBUILD 打包脚本（这就是为什么你可通过 AUR 安装不少明确禁止二次分发的闭源软件的原因，因为 AUR 分发的是打包脚本而不是软件本体），需要下载后进行编译打包安装，如果你懒得自己打包的话，建议添加 archlinuxcn 源。在配置完成中文字体的显示后，在 KDE 的系统设置中将语言设置为中文就行了。另外，强烈建议阅读官方的&lt;a class="link" href="https://wiki.archlinux.org/index.php/Arch_Linux_%E4%B8%AD%E6%96%87%E5%8C%96" target="_blank" rel="noopener"
> Arch Linux 中文化&lt;/a>页面。&lt;/p>
&lt;h2 id="翻墙">翻墙
&lt;/h2>&lt;p>折腾 Linux 总是会遇到各种问题，这种时候便需要 Google 了，让我们先解决使用无法使用 Google 的问题（此处使用 V2Ray 作为例子，在官方软件仓库有 V2Ray 的软件包真是太好了）：&lt;/p>
&lt;pre>&lt;code>yay -S v2ray
&lt;/code>&lt;/pre>
&lt;p>安装后修改/etc/v2ray/config.json 的配置，然后：&lt;/p>
&lt;pre>&lt;code>sudo systemctl enable v2ray.service
sudo systemctl start v2ray.service
&lt;/code>&lt;/pre>
&lt;p>如果想让桌面应用走代理，可以在 KDE 的系统设置中点击“网络”中的设置，然后点击“代理”，选中“使用系统代理服务器配置”，填入对应的代理信息，示例如下：&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Try_Arch_Linux/set_kde_proxy.png"
width="1074"
height="736"
loading="lazy"
alt="KDE 设置系统代理"
class="gallery-image"
data-flex-grow="145"
data-flex-basis="350px"
>&lt;/p>
&lt;p>另外，V2Ray 支持 ShadowSocks 协议，可根据&lt;a class="link" href="https://www.v2ray.com/chapter_02/protocols/shadowsocks.html" target="_blank" rel="noopener"
> V2Ray 官方文档&lt;/a>写出配置文件，也可使用&lt;a class="link" href="https://www.veekxt.com/utils/v2ray_gen" target="_blank" rel="noopener"
>在线工具&lt;/a>生成；如果你使用 SSR 翻墙，AUR 中有&lt;a class="link" href="https://aur.archlinux.org/packages/electron-ssr/" target="_blank" rel="noopener"
> electron-ssr&lt;/a>，也有&lt;a class="link" href="https://aur.archlinux.org/packages/shadowsocksr/" target="_blank" rel="noopener"
> shadowsocksr&lt;/a>，但需要注意的是 electron-ssr 无法在 KDE 下自动设置代理（它使用了 gsetting 设置系统代理，不支持 KDE）。总之，安装好翻墙软件后终于能在电脑上使用 Google 查问题了。&lt;/p>
&lt;h1 id="终端模拟器与-shell">终端模拟器与 Shell
&lt;/h1>&lt;p>既然在 Linux 下，那么肯定免不了与终端打交道，既然如此，我们就需要一个美观、实用的终端（模拟器）。要说美观的话，KDE 自带的 Konsole 已经足够漂亮了，透明背景这一点让一直使用 Gnome Terminal 的我感到非常舒服，只需要稍微调整一下，就可以做到&lt;a class="link" href="https://kirikira.moe/post/28/#3" target="_blank" rel="noopener"
> kiri 大佬这样的效果&lt;/a>，让自己一整天都保持心情愉悦。不过在实用性方面我开始时遇到了一点问题，Konsole 使用的 Shell 是 Bash，而 Arch Linux 本身的 Bash 并没有自动补全配置，想要自动补全的话需要安装 bash-completion：&lt;/p>
&lt;pre>&lt;code>sudo pacman -S bash-completion
&lt;/code>&lt;/pre>
&lt;p>想要更高级的 Shell 体验的话（不知道终端模拟器与 Shell 有什么区别？请看&lt;a class="link" href="https://www.ihewro.com/archives/933/" target="_blank" rel="noopener"
>这&lt;/a>），也可以安装 zsh 加 oh-my-zsh 这样一整套的懒人包（或者自己配置 zsh？），只不过这里有一个小坑，在 AUR 中的 oh-my-zsh-git 并不会在 home 目录下生成 .zshrc，查找后发现在 /usr/share/oh-my-zsh 下有 zshrc 文件，我直接复制到 home 目录了，这里贴出安装懒人包的操作命令（将 username 改为你的用户名）：&lt;/p>
&lt;pre>&lt;code>yay -S zsh
sudo chsh -s /bin/zsh username
yay -S oh-my-zsh-git
cp /usr/share/oh-my-zsh/zshrc ~/.zshrc
&lt;/code>&lt;/pre>
&lt;p>*更新：博主已经放弃启动速度慢的 oh-my-zsh，转向 Zinit 这个神器的怀抱了，另外，2021 年 11 月 Zinit 的原作者删除代码库，目前由 zdharma-continuum 组织接手进行维护，请注意 URL 的变化。*Zinit 不仅轻松可以使用 oh-my-zsh 的各种插件，还拥有 Turbo mode 这个大幅减少插件加载时间的大杀器。如果你心动的话，请看&lt;a class="link" href="https://www.aloxaf.com/2019/11/zplugin_tutorial/" target="_blank" rel="noopener"
>加速你的 zsh —— 最强 zsh 插件管理器 zplugin/zinit 教程&lt;/a>一文。仅仅是照抄文末的示例配置，我也在保留 oh-my-zsh 体验的前提下感受到了起飞的加载速度，所以请无视上面的 oh-my-zsh，使用以下指令体验顺滑如丝的 Zinit（这里用了没什么配置难度的 proxychains-ng 翻墙下载 GitHub 片段，也可使用其它手段）：&lt;/p>
&lt;pre>&lt;code>yay -S zsh proxychains-ng
git clone https://github.com/zdharma-continuum/zinit.git ~/.zinit/bin
# 在 .zshrc 中添加 source ~/.zinit/bin/zinit.zsh 以及其它配置，可参考我的配置
nano .zshrc
# 配置 proxychains-ng，在最后一行添加类似 socks5 127.0.0.1 1080 的内容即可，自行谷歌了解配置
sudo nano /etc/proxychains.conf
# 启动 zsh，由于 .zshrc 已加载 Zinit，所以 zsh 首次启动时会自行下载 GitHub 上的片段
proxychains zsh
# 下载片段完成后退出执行这条指令更改默认 Shell，重启后见效果
sudo chsh -s /bin/zsh username
&lt;/code>&lt;/pre>
&lt;p>你可以在&lt;a class="link" href="https://github.com/vifly/dotfiles/blob/master/zsh/.zshrc" target="_blank" rel="noopener"
> GitHub &lt;/a>查看我的 zsh 配置，不过请记得根据自己的需求进行修改。&lt;/p>
&lt;h1 id="输入法">输入法
&lt;/h1>&lt;p>前面搞定了中文字体的显示，但是还没解决输入中文这个问题，在这里我选择了与使用 Debian 时同样的方案：基于 Fcitx 框架的 Rime 输入法。先贴一波安装指令（其它基于 Fcitx 框架的输入法请看&lt;a class="link" href="https://wiki.archlinux.org/index.php/Fcitx" target="_blank" rel="noopener"
> Wiki 页面&lt;/a>）：&lt;/p>
&lt;pre>&lt;code>sudo pacman -S fcitx fcitx-im fcitx-rime
&lt;/code>&lt;/pre>
&lt;p>为了确保能输入中文，修改一下/etc/profile，在开头加上：&lt;/p>
&lt;pre>&lt;code>export XMODIFIERS=&amp;quot;@im=fcitx&amp;quot;
export GTK_IM_MODULE=&amp;quot;fcitx&amp;quot;
export QT_IM_MODULE=&amp;quot;fcitx&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>另外，需要更改一下输入法配置，操作步骤是右键点击托盘中的输入法图标，选择“配置”，修改后的配置如下图所示（按 Shift 键可切换中英文）：&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Try_Arch_Linux/set_fcitx_1.png"
width="683"
height="820"
loading="lazy"
alt="输入法配置图1"
class="gallery-image"
data-flex-grow="83"
data-flex-basis="199px"
>&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Try_Arch_Linux/set_fcitx_2.png"
width="681"
height="816"
loading="lazy"
alt="输入法配置图2"
class="gallery-image"
data-flex-grow="83"
data-flex-basis="200px"
>&lt;/p>
&lt;p>最后，将我已经在 Debian 上调校好的 Rime 输入法配置文件拷贝过来（调校 Rime 的教程太多了，这里懒得贴了～），就能畅快地输入中文了。&lt;/p>
&lt;h1 id="多媒体">多媒体
&lt;/h1>&lt;p>这里选择在 Debian 上非常熟悉的 MPV 和 Rhythmbox 作为视频和音频播放器，之所以选择 MPV 是因为我已经有了一套&lt;a class="link" href="https://github.com/vifly/dotfiles/blob/master/mpv/.config/mpv/mpv.conf" target="_blank" rel="noopener"
>配置方案&lt;/a>，没必要选择其它播放器了，如果你还没使用过 MPV，那么&lt;a class="link" href="https://vcb-s.com/archives/7594/comment-page-1" target="_blank" rel="noopener"
>这里&lt;/a>有一篇相当不错的配置教程。而 Rhythmbox 支持不少插件，例如，在 KDE 桌面下，Rhythmbox 无法在关闭窗口时隐藏到托盘继续播放，可以通过安装 rhythmbox-tray-icon 插件解决：&lt;/p>
&lt;pre>&lt;code>yay -S rhythmbox-tray-icon
&lt;/code>&lt;/pre>
&lt;p>安装好插件后记得点击 Rhythmbox 右上角的设置按钮-&amp;gt;“插件”，在弹出的窗口中勾选刚安装的插件以激活插件效果，如下图：&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Try_Arch_Linux/rhythmbox_plugin.png"
width="778"
height="598"
loading="lazy"
alt="Rhythmbox 插件"
class="gallery-image"
data-flex-grow="130"
data-flex-basis="312px"
>&lt;/p>
&lt;p>除此以外，我还推荐 rhythmbox-equalizer 插件，安装后可调整 EQ。&lt;/p>
&lt;h1 id="生产力">生产力
&lt;/h1>&lt;p>属于生产力的工具有很多，我在这里只选择分享几个比较重要的工具。如果平常使用的生产力工具没有 Linux 客户端，或许可用网页版代替客户端（连网页版都没有的话，折腾下 wine 或放弃在 Linux 下使用吧）。&lt;/p>
&lt;h2 id="浏览器">浏览器
&lt;/h2>&lt;p>都说程序猿是面向 Google 编程的，既然如此，怎能缺少一个趁手的浏览器用于查资料呢。直接安装我在 Debian 上一直在使用的 Firefox 与 Chromium（Google Chrome 的开源部分）：&lt;/p>
&lt;pre>&lt;code>yay -S firefox-i18n-zh-cn chromium
&lt;/code>&lt;/pre>
&lt;p>这两个浏览器都有云同步机制，可直接将在其它平台上的浏览器资料同步过来，不想使用云同步的话，也可以手动复制用户资料以进行数据备份和迁移，Chromium 的用户资料在~/.config/chromium/Default/，浏览器扩展及其数据存放在这个目录下带有“Extensions”的子目录中；Firefox 有些不同，它轻松支持多个用户配置，你可以打开&lt;a class="link" href="about:profiles" > about:profiles &lt;/a>页面查看用户配置文件路径，显示“正在使用此配置文件，因而不能删除。”的就是当前的用户配置文件。 &lt;br>
对于我来说，选择这两个浏览器的一个重要原因就是可以安装扩展改善各种功能，例如禁用 JS 的 NoScript/ScriptSafe，拦截广告的 uBlock，为网页注入实用 JS 的 Greasemonkey，对于 Firefox 用户，还可参考编程随想的&lt;a class="link" href="https://program-think.blogspot.com/2016/10/custom-firefox-theme-without-extension.html" target="_blank" rel="noopener"
>无需任何插件或扩展，定制 Firefox 外观&lt;/a>和&lt;a class="link" href="https://program-think.blogspot.com/2019/07/Customize-Firefox.html" target="_blank" rel="noopener"
>扫盲 Firefox 定制——从“user.js”到“omni.ja”&lt;/a>进行更高级的定制。另外，从安全补丁的及时性这一角度来说，我也更推荐这两个浏览器，而不是基于这两者的衍生版。&lt;/p>
&lt;h2 id="代码编辑器与ide">代码编辑器与IDE
&lt;/h2>&lt;p>要问对程序猿而言最重要的生产力工具是什么，回答肯定是代码编辑器或 IDE。目前在 Linux 下我喜欢的编辑器就是 Visual Studio Code（简称 VS Code）了，虽然这是微软出品的（别跟 VS 搞混了，两者之间的差别非常大），不过用了以后还是要说一句“真香！”。它可以胜任多种需求，常见的 Python、C/C++等完全不在话下，也可以用作 Markdown 写作，像本文就是在 VS Code 下完成的，当然，值得一提的还有美观的界面，开箱即用的设置，这都令它在短时间内打动了我，再配合各种扩展，带来的是十分舒适的体验。对于 VS Code，我目前推荐 TabNine 以及 Markdown Preview Enhanced 这两个扩展，前者带来优秀的主流编程语言自动补全，后者带来更高级的 Markdown 预览体验（例如查看 LaTex）。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Try_Arch_Linux/vs_code.png"
width="1920"
height="1043"
loading="lazy"
alt="VS Code 图"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="441px"
>&lt;/p>
&lt;p>如果需要一个 IDE 的话，我推荐由 JetBrains 出品的 IDE，应该有不少人用过它家的 PyCharm 了，除此以外，Clion (C/C++) 与 IntelliJ IDEA (Java) 也是非常优秀的 IDE，至少在目前来说，Clion 对 Cmake 项目的支持可比 VS 好多了。另外，配合 Github 的学生认证可以白嫖 JetBrains 的产品，在此强烈推荐学生党尝试一下 Clion。&lt;/p>
&lt;h2 id="笔记">笔记
&lt;/h2>&lt;p>作为一个程序猿，总是会有记录笔记的需求，我目前有相当一部分的笔记资料储存在 EverNote 这个云笔记上，而它并没有 Linux 官方客户端，不过，得益于它的开放 API，早就有开发者做了一个在 Linux 下的客户端：NixNote（原名 Nevernote），Arch Linux 官方仓库有这个软件包：&lt;/p>
&lt;pre>&lt;code>sudo pacman -S nixnote2
&lt;/code>&lt;/pre>
&lt;p>&lt;del>只不过我遇到了在已设置应用程序使用语言为中文的情况下，菜单依然为英文的问题，Google 后找到一篇&lt;a class="link" href="https://blue-leaf81.net/archives/nixnote-translate-jp/" target="_blank" rel="noopener"
>让 NixNote 显示日语的教程&lt;/a>，受到这篇教程的启发，我查看了一下/usr/share/nixnote2/translations/目录，发现其中只有 nixnote2_cs_CZ.qm 文件，看来想要让菜单显示中文，就必须在这个目录下添加中文翻译。具体来说，先前往 GitHub 仓库下载&lt;a class="link" href="https://github.com/baumgarr/nixnote2/blob/master/translations/nixnote2_zh_CN.ts" target="_blank" rel="noopener"
>中文翻译源文件&lt;/a>，接着使用 Qt Linguist 打开下载回来的文件，然后点击左上角“File”-&amp;gt;&amp;ldquo;Release As&amp;quot;导出到/usr/share/nixnote2/translations/nixnote2_zh_CN.qm。重启 NixNote 便可以看到中文菜单了&lt;/del>。更新：2020年5月的更新已带上中文翻译，无需再按上面折腾。 &lt;br>
当然，EverNote 在 Linux 下还有&lt;a class="link" href="https://itsfoss.com/evernote-on-linux/" target="_blank" rel="noopener"
>几个非官方客户端&lt;/a>，我选择 NixNote 的原因在于它是使用 C++ QT 开发的，而不是类似于&lt;a class="link" href="https://github.com/klauscfhq/tusk" target="_blank" rel="noopener"
> Tusk &lt;/a>等使用前端技术开发的套壳 Web 应用，但对于 EverNote 的高级用户，我建议使用 EverNote 的网页版，而不是使用 NixNote，因为网页版的编辑功能比 NixNote 更优秀。&lt;/p>
&lt;h2 id="虚拟机">虚拟机
&lt;/h2>&lt;p>我有时候会有使用虚拟机运行 Windows 或其它 Linux 发行版的需求，这个时候就需要用到虚拟机了，VirtualBox 是一个操作简单且免费开源的虚拟机软件，根据&lt;a class="link" href="https://wiki.archlinux.org/index.php/VirtualBox" target="_blank" rel="noopener"
> Wiki 页面&lt;/a>进行安装（安装时会要求选择内核模块，没有更换默认内核的话，选择 virtualbox-host-modules-arch，不然选择 virtualbox-host-dkms）：&lt;/p>
&lt;pre>&lt;code>yay -S virtualbox virtualbox-ext-oracle virtualbox-guest-iso
&lt;/code>&lt;/pre>
&lt;p>假如你没有用过 VirtualBox，那么这里提醒一句，拖放文件和共享粘贴板等功能需要在运行中的虚拟机窗口上方点击“设备”-&amp;gt;“安装增强功能”才可使用。&lt;/p>
&lt;h1 id="后记">后记
&lt;/h1>&lt;p>得益于我对软件的通用性的要求，可以说是无痛从 Debian 迁移到了 Arch Linux，不少软件只需简单地复制粘贴配置文件即可（前提是已经有配置文件了），而且 Arch Linux 的系统安装过程也并不像我之前想象的那样复杂。折腾完这堆东西后最大的感触就是之前折腾积累的东西（如相关知识与配置）并没有浪费，若是没有相关的积累，面对安装 Arch Linux 以及安装完成后做什么这些问题恐怕会一头雾水，浪费不少时间，从节约时间的角度来说，编程随想所说的&lt;a class="link" href="https://program-think.blogspot.com/2013/10/personal-it-infrastructure.html" target="_blank" rel="noopener"
>重视个人 IT 基础设施的改善&lt;/a>是很有道理的。总之，安装好 Arch Linux 的我就像是一个刚得到新玩具的小孩子，正迫不及待地想要探索这个新玩具的有趣之处，更多有趣的软件留待日后补充好了。&lt;/p></description></item><item><title>Debian 安装 Matomo (Piwik) 开源统计分析服务</title><link>https://viflythink.com/Install_Matomo_on_Debian/</link><pubDate>Sun, 18 Aug 2019 00:00:00 +0800</pubDate><guid>https://viflythink.com/Install_Matomo_on_Debian/</guid><description>&lt;img src="https://viflythink.com/Install_Matomo_on_Debian/show.jpg" alt="Featured image of post Debian 安装 Matomo (Piwik) 开源统计分析服务" />&lt;h1 id="前言">前言
&lt;/h1>&lt;p>之前我在&lt;a class="link" href="https://viflythink.com/Use_GithubPages_and_Hexo_to_build_blog_advanced/#%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90" target="_blank" rel="noopener"
>使用Github Pages和Hexo搭建个人博客(进阶篇)&lt;/a>这一篇博文中已经提到了不考虑使用大型公司提供的网站统计分析服务了，只不过网站统计分析服务还是有必要的，至少能看到有多少人浏览过自己的网站。之所以不采用商业公司提供的分析服务是因为这等于助纣为虐，帮助这些公司建立更精准的用户画像，这些公司可以利用遍布于大半个互联网的自家的跟踪代码对读者进行浏览痕迹的跟踪，从而建立精准的用户画像，我无法接受这种侵犯用户隐私的行为，所以只能考虑自己搭建统计分析服务了。在 Google 上搜了一下后决定采用 Matomo（原名为 Piwik）这个开源的网站统计分析服务。本文主要参考了&lt;a class="link" href="https://my.oschina.net/u/3944788/blog/2874366" target="_blank" rel="noopener"
>在Debian 9上安装Matomo Analytics&lt;/a>这一个教程，只不过很不巧的是目前 Debain 10 已经发布，这篇教程里的 php7.0 已经过时，但是没关系，下文中提供的安装 php 的指令并没有指定版本，所以对于 Debian 9/10 的用户都是可行的。&lt;/p>
&lt;h1 id="需求">需求
&lt;/h1>&lt;p>1.基本的 Linux 终端操作经验&lt;br>
2.一个安装了 Debian 9/10 的服务器（VPS），理论上来说 Ubuntu 18 也可以（并没有实测过）&lt;br>
3.一个属于自己的域名，并且已经将其 DNS 解析指向自己的服务器&lt;/p>
&lt;h1 id="操作">操作
&lt;/h1>&lt;p>先安装必须的库：&lt;/p>
&lt;pre>&lt;code>sudo apt install unzip apt-transport-https curl wget dirmngr php php-fpm php-curl php-gd php-cli php-mysql php-xml php-mbstring
&lt;/code>&lt;/pre>
&lt;p>安装 MySQL 的替代品 MariaDB，这里必须提到的一点是，从 Debian9 开始，&lt;a class="link" href="https://mariadb.org/debian-9-released-mariadb-mysql-variant/" target="_blank" rel="noopener"
>软件包仓库中的 MySQL 实际上已经全被 MariaDB 取代了&lt;/a>：&lt;/p>
&lt;pre>&lt;code>sudo apt install mariadb-server
&lt;/code>&lt;/pre>
&lt;p>运行 mysql_secure_installation 脚本以改进 MariaDB 安装的安全性：&lt;/p>
&lt;pre>&lt;code>sudo mysql_secure_installation
&lt;/code>&lt;/pre>
&lt;p>作为数据库 root 用户登录到 MariaDB（注意，必须使用 root 权限才可以作为数据库 root 用户登录到 MariaDB，数据库的 root 用户与系统中的 root 用户不是同一个东西）：&lt;/p>
&lt;pre>&lt;code>sudo mysql -u root -p
&lt;/code>&lt;/pre>
&lt;p>假如没有一个用于 Matomo 的数据库用户的话，先执行以下指令新建数据库用户，localhost 意味这个用户只可以本地登录（&lt;em>PS：记得将username和password替换为自己准备设置的用户名和密码，下同&lt;/em>）：&lt;/p>
&lt;pre>&lt;code>CREATE USER 'username'@'localhost' IDENTIFIED BY 'password';
&lt;/code>&lt;/pre>
&lt;p>创建后请记住用户名和密码。&lt;br>
创建一个新的 MariaDB 数据库并授权：&lt;/p>
&lt;pre>&lt;code>CREATE DATABASE db_name;
GRANT ALL ON db_name.* TO 'username' IDENTIFIED BY 'password';
FLUSH PRIVILEGES;
quit;
&lt;/code>&lt;/pre>
&lt;p>安装 nginx：&lt;/p>
&lt;pre>&lt;code>sudo apt install -y nginx
&lt;/code>&lt;/pre>
&lt;p>新建 Nginx 配置文件：&lt;/p>
&lt;pre>&lt;code>sudo nano /etc/nginx/sites-available/matomo
&lt;/code>&lt;/pre>
&lt;p>在其中填入（将 your_domain 替换为你的域名，例如 stats.viflythink.com，fastcgi_pass 的内容请根据自己的版本进行填写，你可以通过 ls /run/php/ 看到对应的 sock 文件）：&lt;/p>
&lt;pre>&lt;code>server {
listen 80;
server_name your_domain;
root /var/www/html/matomo;
location / {
try_files $uri /index.php$is_args$args;
}
location ~ \.php$ {
try_files $uri =404;
include fastcgi_params;
fastcgi_pass unix:/run/php/php7.0-fpm.sock;
fastcgi_index index.php;
fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
}
}
&lt;/code>&lt;/pre>
&lt;p>通过建立软链接将刚写好的配置文件对应的网站设置为可访问的：&lt;/p>
&lt;pre>&lt;code>sudo ln -s /etc/nginx/sites-available/matomo /etc/nginx/sites-enabled/
&lt;/code>&lt;/pre>
&lt;p>测试配置：&lt;/p>
&lt;pre>&lt;code>sudo nginx -t
&lt;/code>&lt;/pre>
&lt;p>创建 matomo 目录：&lt;/p>
&lt;pre>&lt;code>sudo mkdir -p /var/www/html/matomo
&lt;/code>&lt;/pre>
&lt;p>下载和解压 matomo：&lt;/p>
&lt;pre>&lt;code>cd /var/www/html/matomo
wget https://builds.piwik.org/piwik.zip
unzip piwik.zip
rm piwik.zip
mv piwik/* .
rmdir piwik
&lt;/code>&lt;/pre>
&lt;p>更改该目录的所有权，确保访问者可以访问这些页面文件：&lt;/p>
&lt;pre>&lt;code>sudo chown -R www-data:www-data /var/www/html/matomo
&lt;/code>&lt;/pre>
&lt;p>重新加载 Nginx 以让配置生效：&lt;/p>
&lt;pre>&lt;code>sudo systemctl reload nginx.service
&lt;/code>&lt;/pre>
&lt;p>接下来使用浏览器打开 Nginx 配置文件中填写的域名，按照指引完成 matomo 的安装。&lt;/p></description></item><item><title>使用 GitHub Pages 和 Hexo 搭建个人博客(进阶篇)</title><link>https://viflythink.com/Use_GithubPages_and_Hexo_to_build_blog_advanced/</link><pubDate>Mon, 15 Jul 2019 00:00:00 +0800</pubDate><guid>https://viflythink.com/Use_GithubPages_and_Hexo_to_build_blog_advanced/</guid><description>&lt;p>&lt;em>2019.8.18.更新：增加了如何搭建自己的统计分析服务的说明。&lt;/em>&lt;br>
&lt;em>2019.9.13.更新：增加了更多的 SEO 内容，对一些内容进行修改。&lt;/em>&lt;br>
&lt;em>2019.11.9.更新：增加了 Material 主题添加随机标语（slogan）的方法。&lt;/em>&lt;br>
在&lt;a class="link" href="https://viflythink.com/Use_GithubPages_and_Hexo_to_build_blog" target="_blank" rel="noopener"
>上一篇博文&lt;/a>当中我已经说完了使用 GitHub Pages 和 Hexo 搭建博客的基础操作了，只是这个刚搭建好的博客还缺了不少经常能在别人的博客上看到的东西，例如 RSS 订阅，评论区等功能。同时，不知道各位有没有发现一个问题，在搜索引擎当中搜索自己的站点时，搜索引擎返回的结果中并不会出现你的站点。本篇教程将会说明如何解决这些问题，如果还有更多的问题，请在评论区留言。&lt;/p>
&lt;h1 id="额外的功能与服务">额外的功能与服务
&lt;/h1>&lt;p>&lt;em>下面提到的这些功能与自己使用的 Hexo 主题相关，存在某些主题并没有提供某项功能的可能性&lt;/em>&lt;/p>
&lt;h2 id="rss-订阅">RSS 订阅
&lt;/h2>&lt;p>想要提供 RSS 订阅这个功能，各位需要查看自己使用的 Hexo 主题的文档进行操作，以我使用的 Material 主题为例，&lt;a class="link" href="https://github.com/viosey/material-theme-docs/blob/master/services-zh-cn.md" target="_blank" rel="noopener"
>官方文档&lt;/a>简单地说明了一下，其实就是在安装了&lt;a class="link" href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener"
> hexo-generator-feed &lt;/a>插件后，修改 Material 主题下的配置文件（_config.yml）中的 rss:的值：&lt;/p>
&lt;pre>&lt;code>url:
rss: atom.xml
&lt;/code>&lt;/pre>
&lt;p>按照这样配置的话，你的博客的 RSS 订阅地址就是 &lt;a class="link" href="https://%e4%bd%a0%e7%9a%84%e5%8d%9a%e5%ae%a2%e5%9f%9f%e5%90%8d/atom.xml" target="_blank" rel="noopener"
>https://你的博客域名/atom.xml&lt;/a>，例如我的博客的 RSS 订阅地址就是 &lt;a class="link" href="https://vifly.github.io/atom.xml" target="_blank" rel="noopener"
>https://vifly.github.io/atom.xml&lt;/a>。&lt;/p>
&lt;h2 id="评论区">评论区
&lt;/h2>&lt;p>依然使用 Material 主题举例子，&lt;a class="link" href="https://github.com/viosey/material-theme-docs/blob/master/services-zh-cn.md" target="_blank" rel="noopener"
>官方文档&lt;/a>也说明了如何设置评论系统，为了能让读者畅所欲言，我否决了全部的国内评论系统，同时为了不翻墙的读者的体验以及匿名评论的需求，我最后选择了 Material 主题提供的 &lt;a class="link" href="https://disqus.com/" target="_blank" rel="noopener"
>Disqus&lt;/a> 加自建 &lt;a class="link" href="https://posativ.org/isso/docs/" target="_blank" rel="noopener"
>Isso&lt;/a> 评论系统（这里要感谢 &lt;a class="link" href="https://alynx.one" target="_blank" rel="noopener"
>Alynx Zhou&lt;/a> 提供的多评论系统前端代码，话说周老师不去当前端工程师是不是太浪费了鸭≧▽≦）。&lt;/p>
&lt;h2 id="数据统计与分析">数据统计与分析
&lt;/h2>&lt;p>继续贴&lt;a class="link" href="https://github.com/viosey/material-theme-docs/blob/master/services-zh-cn.md" target="_blank" rel="noopener"
>官方文档&lt;/a>。基于对读者隐私的考虑，我直接排除了百度和 CNZZ 的分析系统，至于 Google 分析，考虑到谷歌近年来的名声与未翻墙用户的体验，最终也决定不予采用，那么就只剩下一条路了，自己搭建分析系统。&lt;del>这个暂时也咕咕咕了，若是能成功搭建的话，再写一篇博文进行叙述。&lt;/del> 目前已经成功使用 Matemo 搭建了自己的网站统计分析服务，具体操作请看&lt;a class="link" href="https://viflythink.com/Install_matomo_on_debian/" target="_blank" rel="noopener"
> Debian 安装 Matomo (Piwik) 开源统计分析服务&lt;/a>。&lt;/p>
&lt;h1 id="搜索引擎优化seo">搜索引擎优化（SEO）
&lt;/h1>&lt;p>假如你在搜索引擎中输入 site:xxxxx.github.io（自己的博客网址） 后发现没有出现自己的网站，那么请赶快看一下下面的“提交网站站点地图”小节。&lt;/p>
&lt;h2 id="验证网站所有权">验证网站所有权
&lt;/h2>&lt;p>为了便于以后在各个搜索引擎当中管理和查看我们的博客，我强烈建议在各个搜索引擎验证网站所有权，完成这一步后即可使用站长工具查看数据了，而且这也是完成后面某些步骤的必要前提。假如你将自己的域名（指的是 *.github.io 以外的域名）用作博客的域名，那么便可以通过添加 DNS 记录的方式验证所有权（&lt;em>PS：每家搜索引擎对这个验证方法有不同的称呼，谷歌称为“域名提供商”，而 Bing 称为“手动向 DNS 添加 CNAME 记录”&lt;/em>），不采用下面提到的方法了。&lt;/p>
&lt;h3 id="google">Google
&lt;/h3>&lt;p>前往 Google 搜索的&lt;a class="link" href="https://search.google.com/search-console/ownership" target="_blank" rel="noopener"
>控制台&lt;/a>添加自己的博客地址即可，Google 提供了几种验证方式:&lt;br>
&lt;img src="https://viflythink.com/Use_GithubPages_and_Hexo_to_build_blog_advanced/google_add_site.png"
width="627"
height="735"
loading="lazy"
alt="Google 的网站所有权验证"
class="gallery-image"
data-flex-grow="85"
data-flex-basis="204px"
> &lt;br>
对于 Material 主题，请使用 HTML 标记或 Google 分析（假如你的博客使用了 Google 分析）进行验证，具体操作只需看&lt;a class="link" href="https://github.com/viosey/material-theme-docs/blob/master/intro-zh-cn.md" target="_blank" rel="noopener"
>官方文档&lt;/a>。&lt;/p>
&lt;h3 id="bing必应">Bing（必应）
&lt;/h3>&lt;p>前往 Bing 的&lt;a class="link" href="https://www.bing.com/toolbox/webmaster/" target="_blank" rel="noopener"
>网站管理员工具&lt;/a>进行验证。很不幸的是，Material 主题官方并没有提供 Bing 的站点所有权验证，那只能自己动手修改源代码了，经过一番查找，终于找到了用于在 HTML 页面当中标记所有权的部分，其代码位于 themes/material/layout/_partial/head.ejs 中，CTRL+F 查找“site_verification”发现在约 142 行的位置就是我们要找的代码，在下方照葫芦画瓢地加上：&lt;/p>
&lt;pre>&lt;code>&amp;lt;% if(theme.head.site_verification.bing) { %&amp;gt;&amp;lt;meta name=&amp;quot;msvalidate.01&amp;quot; content=&amp;quot;&amp;lt;%= theme.head.site_verification.bing %&amp;gt;&amp;quot; /&amp;gt;&amp;lt;% } %&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>注意，我感觉这里的 meta name 不一定对于每个人都适用，请观察一下 Bing 提供的 HTML 代码后再修改 head.ejs。&lt;/strong>&lt;br>
&lt;img src="https://viflythink.com/Use_GithubPages_and_Hexo_to_build_blog_advanced/bing_add_site.png"
width="1023"
height="785"
loading="lazy"
alt="Bing 的网站所有权验证"
class="gallery-image"
data-flex-grow="130"
data-flex-basis="312px"
>
在复制了“&amp;lt;meta name=&amp;ldquo;msvalidate.01&amp;rdquo; content=&amp;ldquo;xxxxxxxxxx&amp;rdquo; /&amp;gt;”中的 xxxxxxxxxx 对应的值后，在主题的_config.yml 中进行修改：&lt;/p>
&lt;pre>&lt;code>site_verification:
bing: xxxxxxxxxx
google:
baidu:
&lt;/code>&lt;/pre>
&lt;h2 id="提交网站站点地图">提交网站站点地图
&lt;/h2>&lt;p>这一步就是告诉搜索引擎你的网站有哪些链接，提交后搜索引擎就会自动顺着站点地图中的链接爬取你的站点内容了，若是没有这一步，在搜索引擎当中直接搜索自己的博客地址是没有任何结果的。要完成这一步骤，需要在博客目录下输入以下指令安装&lt;a class="link" href="https://github.com/hexojs/hexo-generator-sitemap" target="_blank" rel="noopener"
> hexo-generator-sitemap &lt;/a>插件：&lt;/p>
&lt;pre>&lt;code>npm install hexo-generator-sitemap --save
&lt;/code>&lt;/pre>
&lt;p>这个插件默认站点地图生成路径为 &lt;a class="link" href="https://%e4%bd%a0%e7%9a%84%e5%8d%9a%e5%ae%a2%e5%9f%9f%e5%90%8d/sitemap.xml" target="_blank" rel="noopener"
>https://你的博客域名/sitemap.xml&lt;/a>，在使用 hexo g 重新生成网址内容后，将此网址提交到各个搜索引擎就可以了，以 Google 为例子，只需要发送 &lt;a class="link" href="http://www.google.com/ping?sitemap=https://" target="_blank" rel="noopener"
>http://www.google.com/ping?sitemap=https://&lt;/a>你的博客域名/sitemap.xml 这个网络请求即可，也可以在&lt;a class="link" href="https://search.google.com/search-console/" target="_blank" rel="noopener"
>Google 搜索控制台&lt;/a>中的 sitemaps（站点地图）一栏提交自己的站点地图。而 Bing 则是需要在其 Web 面板中添加 sitemap。&lt;/p>
&lt;h2 id="提交网页地址收录新页面">提交网页地址（收录新页面）
&lt;/h2>&lt;p>虽然搜索引擎会自动顺着站点地图爬取网页内容，但是我就是想让它赶快收录刚发布的文章（因为不知道这个这个自动流程需要多少时间），这种时候该怎么办呢？我从&lt;a class="link" href="http://www.guxiaobei.com/submit-your-content-of-google.html" target="_blank" rel="noopener"
>“SEO 技巧！如何最快时间让 Google 收录你的页面”&lt;/a>中了解到了如何让 Google 及时收录新发布的博文，然而 Google 的控制台页面已经进行了改版，经过一番搜索，在&lt;a class="link" href="https://support.google.com/webmasters/answer/9012289" target="_blank" rel="noopener"
> Google 官方的帮助文档&lt;/a>找到了新的提交新页面的方法，打开&lt;a class="link" href="https://www.google.com/webmasters/tools" target="_blank" rel="noopener"
>https://www.google.com/webmasters/tools&lt;/a>，转到网址检查，输入你的新页面的网址，这就可以及时提交新的网页了。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Use_GithubPages_and_Hexo_to_build_blog_advanced/submit_new_address.png"
width="1414"
height="756"
loading="lazy"
alt="网址检查"
class="gallery-image"
data-flex-grow="187"
data-flex-basis="448px"
>&lt;/p>
&lt;h2 id="seo-进阶">SEO 进阶
&lt;/h2>&lt;p>为了让搜索引擎更好地爬取我们的网页，还需要使用一些技巧。这一部分主要参考了 &lt;a class="link" href="https://hoxis.github.io/Hexo&amp;#43;Next%20SEO%E4%BC%98%E5%8C%96.html" target="_blank" rel="noopener"
>Hexo 博客 Next 主题 SEO 优化方法&lt;/a>这一博文，虽然 Material 主题与 Next 主题不同，不过有不少地方还是共通的。&lt;/p>
&lt;h3 id="修改文章链接地址">修改文章链接地址
&lt;/h3>&lt;p>Hexo 默认的文章链接形式为 domain/year/month/day/postname，这种四级 url 形式对于搜索引擎而言并不友好，我们可以修改为 domain/postname 这种形式。打开 blog 根目录下的_config.yml（下面统称为&lt;strong>站点配置文件&lt;/strong>），找到 permalink 部分，将 permalink: :year/:month/:day/:title/改为 permalink: :title.html。&lt;/p>
&lt;pre>&lt;code>#permalink: :year/:month/:day/:title/
permalink: :title.html
&lt;/code>&lt;/pre>
&lt;h3 id="出站链接添加-nofollow-标签">出站链接添加 nofollow 标签
&lt;/h3>&lt;p>博文中总是会引用其它的文章，为了不让搜索引擎跳转到其它的网站，专注于我们的网页，我们需要为这些站外链接设置 nofollow 标签，可以通过安装&lt;a class="link" href="https://github.com/liuzc/hexo-autonofollow" target="_blank" rel="noopener"
> hexo-autonofollow &lt;/a>自动完成这一个步骤。&lt;/p>
&lt;pre>&lt;code>npm install hexo-autonofollow --save
&lt;/code>&lt;/pre>
&lt;p>然后在&lt;strong>站点配置文件&lt;/strong>中添加（更多配置请看 GitHub 页面）：&lt;/p>
&lt;pre>&lt;code>nofollow:
enable: true
&lt;/code>&lt;/pre>
&lt;h3 id="添加文章描述">添加文章描述
&lt;/h3>&lt;p>由于在 Material 主题中，文章的 tags 等于 keywords，所以无需再添加关键字了。不过我们可以为每篇博文添加描述，添加方法与添加 tags 等相似，在博客文章 markdown 文件开头添加 description：&lt;/p>
&lt;pre>&lt;code>---
title: 标题
date: year-month-day xx:xx:xx
tags: [tag01,tag02]
description: 你的博文描述
---
&lt;/code>&lt;/pre>
&lt;h1 id="个性化">个性化
&lt;/h1>&lt;h2 id="启用自己的域名">启用自己的域名
&lt;/h2>&lt;p>千篇一律的 xxxxxxx.github.io 总是让人觉得厌烦，说到个性化，怎么能缺少使用自己喜欢的域名作为博客网址这一项呢？使用自定义的域名更有可能让人记住你的博客，而且只要不是前往 GoDaddy 这种价格偏高的网站购买域名，一个普通的 com 顶级域名每年也只需花费 10 美刀左右就可以拥有。在这么多的域名服务商当中，我选择了国外的&lt;a class="link" href="namecheap.com" > namecheap&lt;/a>，主要的好处就是以下几点：&lt;/p>
&lt;ol>
&lt;li>价格便宜（从网站名字就可以看出来了）&lt;/li>
&lt;li>老牌商家，服务可靠。别看这个网站的页面长得不好看，而且价格也比较便宜，但这个网站真的是老牌服务商，我并没有找到它坑客户的案例，基本可以放心。&lt;/li>
&lt;li>提供免费的 WhoisGuard 服务，保护你的隐私。&lt;/li>
&lt;li>不用备案，选择国外的域名服务商的话都能享受到这点。&lt;/li>
&lt;/ol>
&lt;h3 id="自定义的域名与-github-page-的绑定">自定义的域名与 GitHub Page 的绑定
&lt;/h3>&lt;p>买好了域名，接下来要做的事就是让我们的域名能够指向自己的博客啦。这个操作流程十分简单，只需前往自己的域名服务商的控制面板，然后参考这条&lt;a class="link" href="https://www.zhihu.com/question/31377141/answer/87541858" target="_blank" rel="noopener"
>知乎回答&lt;/a>进行操作，只需在域名解析当中添加两条 CNAME 记录让域名（以我的域名为例就是 viflythink.com 和 &lt;a class="link" href="https://www.viflythink.com" target="_blank" rel="noopener"
>www.viflythink.com&lt;/a> ）指向 xxxxxx.github.io，大概就是下面这样： &lt;br>
&lt;img src="https://viflythink.com/Use_GithubPages_and_Hexo_to_build_blog_advanced/set_dns.png"
width="621"
height="173"
loading="lazy"
alt="设置DNS解析"
class="gallery-image"
data-flex-grow="358"
data-flex-basis="861px"
>&lt;br>
然后在 source 目录下新建一个叫 CNAME 的文本文件，里面填入你的域名（如 viflythink.com），与不少网上的操作不同，我们这里并不需要绑定 GitHub 的 IP，因为有时候 IP 地址会变化，所以绑定 xxxxxx.github.io 会更好。&lt;/p>
&lt;h3 id="启用-https-加密">启用 HTTPS 加密
&lt;/h3>&lt;p>为了保证读者的隐私，防止 ISP 的广告植入，稍微提高自己的网站在搜索引擎中的权重，我们需要为自己的域名启用 HTTPS 加密，当你成功启用 HTTPS 加密后读者访问你的网站时就会看到浏览器上出现一个绿色小锁头了，整个步骤也不难，这里参考了&lt;a class="link" href="https://tzhou2018.github.io/2018/04/%E4%B8%BAGitHub-Pages%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%B9%B6%E6%B7%BB%E5%8A%A0SSL-%E5%BC%80%E5%90%AFHTTPS%E5%BC%BA%E5%88%B6/" target="_blank" rel="noopener"
>为 GitHub Pages 自定义域名并添加SSL-开启https强制&lt;/a>这一篇博文，使用 cloudflare 提供的免费服务，这里必须提醒一句，使用 cloudflare 的 &lt;em>Universal SSL&lt;/em> 并不意味着全程加密，这个服务其实是通过 cloudflare 自己的服务器进行中转，读者到 cloudflare 的服务器这一段路是加密的，而 cloudflare 到 GitHub 的这一段并没有加密，另外，我在部署后出现“重定向次数过多”的错误，将 cloudflare 的加密由 Flexible 转为默认的 FULL 后就可以了，暂不知道原因。&lt;/p>
&lt;h2 id="material-主题的进阶设置">Material 主题的进阶设置
&lt;/h2>&lt;h3 id="material-主题实现随机显示标语slogan">Material 主题实现随机显示标语（slogan）
&lt;/h3>&lt;p>是否觉得仅仅一句标语（格言）不足以说明什么呢？我想要在博客首页的标语更能表达我自己，使用随机显示的标语是一个很好的主意，这样就可以使用多个名言警句了，但是 Google 了一番后并没有找到为 Material 主题设置随机标语的方案，那么只能自己动手了（&lt;del>在改源码的道路上越走越远&lt;/del>）。这里主要参考了萌狼的&lt;a class="link" href="https://blog.yoitsu.moe/pelican/new_yoitsu_birth_notes.html" target="_blank" rel="noopener"
>新约伊兹的萌狼乡手札诞生全过程伪实录&lt;/a>里的“实现动态格言”部分，由于我不懂前端，所以最后只能做到在每次刷新网页后显示随机的标语，而不能动态刷新。这里记录下我的折腾过程，欢迎前端大佬帮忙改进。&lt;br>
首先找到 Material 主题负责显示标语的代码，其路径是 themes/material/layout/_partial/daily_pic.ejs，可以看到相关代码：&lt;/p>
&lt;pre>&lt;code>&amp;lt;div class=&amp;quot;mdl-card__media mdl-color-text--grey-50&amp;quot; style=&amp;quot;background-image:url(&amp;lt;%= url_for(theme.img.daily_pic) %&amp;gt;)&amp;quot;&amp;gt;
&amp;lt;p class=&amp;quot;index-top-block-slogan&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;&amp;lt;%= theme.url.daily_pic %&amp;gt;&amp;quot;&amp;gt;
&amp;lt;% if(theme.uiux.slogan) { %&amp;gt;
&amp;lt;% if(Array.isArray(theme.uiux.slogan)) { %&amp;gt;
&amp;lt;%- theme.uiux.slogan.join('&amp;lt;br&amp;gt;') %&amp;gt;
&amp;lt;% } else { %&amp;gt;
&amp;lt;%- theme.uiux.slogan %&amp;gt;
&amp;lt;% } %&amp;gt;
&amp;lt;% } %&amp;gt;
&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>这部分最后会被转换为 HTML 文本，然而我们需要每次加载时都能显示不同的标语，该怎么办呢？答案是使用 document.addEventListener() 设置一个监听器，加载多个标语后随机选择一个显示，这就是我写的代码的思路，当然，由于我是一个前端小白，所以借鉴了萌狼的代码，期间遇到了“$ is not defined”的错误，按照查到的&lt;a class="link" href="https://stackoverflow.com/questions/10779148/javascript-jquery-is-not-defined-function-error" target="_blank" rel="noopener"
> stackoverflow 上的回答&lt;/a>成功解决了（说的简单，其实为了读懂相关的代码花了不少时间），最后写出的能用的代码如下（使用下面的代码替换上面贴出的代码）：&lt;/p>
&lt;pre>&lt;code>&amp;lt;div class=&amp;quot;mdl-card__media mdl-color-text--grey-50&amp;quot; style=&amp;quot;background-image:url(&amp;lt;%= url_for(theme.img.daily_pic) %&amp;gt;)&amp;quot;&amp;gt;
&amp;lt;p id=&amp;quot;myslogan&amp;quot; class=&amp;quot;index-top-block-slogan&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;&amp;lt;%= theme.url.daily_pic %&amp;gt;&amp;quot;&amp;gt;
无法加载 gists 上的标语
&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;!-- 动态显示标语 --&amp;gt;
&amp;lt;script src=&amp;quot;js/jquery.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
document.addEventListener(&amp;quot;DOMContentLoaded&amp;quot;, function() {
jQuery.getJSON( &amp;quot;https://api.github.com/gists/7a04e2188185ddb19cbd19d8217b9400&amp;quot;, function(data) {
slogans = JSON.parse(data.files[&amp;quot;slogans.json&amp;quot;].content);
randomSlogan = slogans[ Math.floor( Math.random() * slogans.length ) ];
jQuery(&amp;quot;#myslogan&amp;quot;).html(randomSlogan.content);
});
});
&amp;lt;/script&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>可以看出，使用了 jQuery 来解析 json 文件和提取标语内容，也用来更改页面中的标语，用 myslogan 这个 ID 标记标语所在区域。另外，想要使用这个代码的话，需要在&lt;a class="link" href="https://gist.github.com/" target="_blank" rel="noopener"
> gist &lt;/a>上创建一个 json 文件，其格式类似于这样（与萌狼不同的是，我的代码并没有显示名言作者，所以这里的 json 文件并不需要填写 author）：&lt;/p>
&lt;pre>&lt;code>[
{
&amp;quot;content&amp;quot;:&amp;quot;example1&amp;quot;
},
{
&amp;quot;content&amp;quot;:&amp;quot;example2&amp;quot;
},
]
&lt;/code>&lt;/pre>
&lt;p>然后将得到的类似于&lt;a class="link" href="https://gist.github.com/7a04e2188185ddb19cbd19d8217b9400" target="_blank" rel="noopener"
>https://gist.github.com/7a04e2188185ddb19cbd19d8217b9400&lt;/a>这样的网址里的&amp;quot;gist.github.com&amp;quot;替换为&amp;quot;api.github.com/gists&amp;quot;，再用这个替换后的网址替换上面代码中的 gist 网址。完成后就能实现打开首页时随机显示标语了。&lt;/p></description></item><item><title>使用 Github Pages 和 Hexo 搭建个人博客</title><link>https://viflythink.com/Use_GithubPages_and_Hexo_to_build_blog/</link><pubDate>Sun, 07 Apr 2019 00:00:00 +0800</pubDate><guid>https://viflythink.com/Use_GithubPages_and_Hexo_to_build_blog/</guid><description>&lt;h1 id="简介">简介
&lt;/h1>&lt;h2 id="github-pages是什么">Github Pages是什么
&lt;/h2>&lt;p>先看看维基百科的说法:&lt;/p>
&lt;blockquote>
&lt;p>GitHub Pages是GitHub提供的一个网页寄存服务，于2008年推出。可以用于存放静态网页，包括博客、项目文档甚至整本书。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a class="link" href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="noopener"
>阮一峰的这篇文章&lt;/a>的说法更为简短：&lt;/p>
&lt;blockquote>
&lt;p>github Pages可以被认为是用户编写的、托管在github上的静态网页。&lt;/p>
&lt;/blockquote>
&lt;p>根据维基百科的介绍，我们可以得知 Github Pages 可用来存放博客，而且是免费且无限存储容量的，只不过它只支持静态网页，也就是说无法使用 WordPress 等工具建站。&lt;/p>
&lt;h2 id="hexo是什么">Hexo是什么
&lt;/h2>&lt;p>先上一个官方的介绍：&lt;/p>
&lt;blockquote>
&lt;p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。&lt;/p>
&lt;/blockquote>
&lt;p>从官方介绍中我们可以得知&lt;strong>Hexo 是用来生成静态网页的&lt;/strong>。
由于 Github Pages 上只能发布静态网页，所以我们需要找到一个生成静态网页的软件来让我们能快速发布博文，Hexo 就是其中的一个。github 官方是推荐使用 Jekyll 来生成和发布的，然而 Hexo 有许多好看的主题，为此我选择了 Hexo。&lt;/p>
&lt;h1 id="本地搭建">本地搭建
&lt;/h1>&lt;h2 id="安装与运行">安装与运行
&lt;/h2>&lt;p>Windows 下请自行下载安装 nodejs 与 git，Linux 请根据自己所使用的发行版安装 nodejs，npm，git。&lt;br>
安装好后输入以下指令安装 hexo-cli（g 参数代表全局，请无视运行过程中出现的错误）：&lt;/p>
&lt;pre>&lt;code>npm install hexo-cli -g
&lt;/code>&lt;/pre>
&lt;p>然后在博客目录下输入以下指令：&lt;/p>
&lt;pre>&lt;code>npm install hexo --save
&lt;/code>&lt;/pre>
&lt;p>完成后可输入 hexo -v 验证是否安装成功。&lt;br>
接着输入以下指令进行初始化：&lt;/p>
&lt;pre>&lt;code>hexo init
&lt;/code>&lt;/pre>
&lt;p>然后输入以下指令安装依赖：&lt;/p>
&lt;pre>&lt;code>npm install
&lt;/code>&lt;/pre>
&lt;p>搞定后就可以运行一下测试效果了，生成静态网页：&lt;/p>
&lt;pre>&lt;code>hexo g
&lt;/code>&lt;/pre>
&lt;p>运行本地服务器：&lt;/p>
&lt;pre>&lt;code>hexo s
&lt;/code>&lt;/pre>
&lt;p>根据输出信息使用浏览器打开&lt;a class="link" href="http://localhost:4000" target="_blank" rel="noopener"
>http://localhost:4000&lt;/a>，即可看到效果&lt;/p>
&lt;h2 id="写文章">写文章
&lt;/h2>&lt;p>可以使用命令行或手动创建方法新建博文。
使用命令行：&lt;/p>
&lt;pre>&lt;code>hexo new &amp;lt;title&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>手动创建：在博客根目录下 source -&amp;gt; _posts 新建以 .md 为后缀的文件。&lt;/p>
&lt;h1 id="主题选择">主题选择
&lt;/h1>&lt;p>就我个人而言，查看技术类博文时总是看到写博文的博主使用了 Next 主题，虽然很简洁，但我总感觉过度简单了，在 16：9 的屏幕上左右两侧的空白太多了。经过一番查找，我选择了在集成服务和美观程度上成功打动了我的 Material 主题。&lt;/p>
&lt;h2 id="使用material主题后运行报错">使用Material主题后运行报错
&lt;/h2>&lt;p>使用 Material 主题后，运行 hexo s 后打开网页报错：&lt;/p>
&lt;pre tabindex="0">&lt;code>Unhandled rejection TypeError: /home/blog/themes/Material/layout/layout.ejs:3
1| &amp;lt;!DOCTYPE html&amp;gt;
2| &amp;lt;html style=&amp;#34;display: none;&amp;#34; &amp;lt;% if(config.language !== null) { %&amp;gt;lang=&amp;#34;&amp;lt;%- config.language.substring(0,2) %&amp;gt;&amp;#34;&amp;lt;% } %&amp;gt;&amp;gt;
&amp;gt;&amp;gt; 3| &amp;lt;%- partial(&amp;#39;_partial/head&amp;#39;) %&amp;gt;
4|
5| &amp;lt;% if(page.layout === &amp;#39;gallery&amp;#39;) { %&amp;gt;
&lt;/code>&lt;/pre>&lt;p>在官方仓库的 issues 中找到了&lt;a class="link" href="https://github.com/viosey/hexo-theme-Material/issues/686" target="_blank" rel="noopener"
>解决方法&lt;/a>，需要对 layout/_widget/dnsprefetch.ejs 进行修改：&lt;br>
将&lt;/p>
&lt;pre>&lt;code>&amp;lt;% } else if(theme.comment.use.startsWith(&amp;quot;disqus&amp;quot;)) { %&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>改为&lt;/p>
&lt;pre>&lt;code>&amp;lt;% } else if(theme.comment.use &amp;amp;&amp;amp; theme.comment.use.startsWith(&amp;quot;disqus&amp;quot;)) { %&amp;gt;
&lt;/code>&lt;/pre>
&lt;h1 id="配置">配置
&lt;/h1>&lt;h2 id="站点配置">站点配置
&lt;/h2>&lt;p>首先打开 blog 根目录下的_config.yml（下面统称为&lt;strong>站点配置文件&lt;/strong>），按照以下示例进行修改：&lt;/p>
&lt;pre>&lt;code>title: 你的站点名称
author: 你的名字
language: zh-CN
&lt;/code>&lt;/pre>
&lt;p>注意冒号后必须有空格，如果你不喜欢默认主题的话，可自行寻找 Hexo 主题，按照对应的主题的说明文档进行安装，记得修改 theme 内容：&lt;/p>
&lt;pre>&lt;code>theme: 新主题名字
&lt;/code>&lt;/pre>
&lt;h2 id="material主题配置">Material主题配置
&lt;/h2>&lt;p>这里按照&lt;a class="link" href="https://github.com/neko-dev/Material-theme-docs/" target="_blank" rel="noopener"
>Material主题官方文档&lt;/a>配置即可，选择 Material 主题的一个重要原因就是这个主题提供了很多对第三方服务的支持（前端小白的福音），所以看看有什么需要的第三方服务吧（RSS，评论区，访问统计等等）,可以参考我写的&lt;a class="link" href="https://viflythink.com/Use_GithubPages_and_Hexo_to_build_blog_advanced" target="_blank" rel="noopener"
>进阶篇&lt;/a>。&lt;/p>
&lt;h2 id="material主题文档的一个小坑">Material主题文档的一个小坑
&lt;/h2>&lt;p>在配置过程中遇到了一个问题，不知道如何在侧边栏添加独立页面的入口（比如关于，友链之类的），添加后点击入口却无法进入对应的页面，官方文档说明如下：&lt;/p>
&lt;blockquote>
&lt;p>link 的参数为相对路径，对应 hexo 目录下的 source 文件夹内的相应文件夹。&lt;/p>
&lt;/blockquote>
&lt;p>然而我已经按照说明创建了文件夹，为什么还是不行呢？最后在&lt;a class="link" href="https://github.com/viosey/hexo-theme-Material/wiki/%E5%88%9B%E5%BB%BA%E3%80%8C%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5%E3%80%8D%E9%A1%B5%E9%9D%A2" target="_blank" rel="noopener"
>这个页面&lt;/a>找到了解决方法，以创建关于页面为例：&lt;br>
在 source 文件夹下创建 about 文件夹，新建一个 index.md 文件，写下（其中 layout 的值不可修改）：&lt;/p>
&lt;pre>&lt;code>---
title: about
date:
layout: about
---
&lt;/code>&lt;/pre>
&lt;p>&lt;em>假如是创建友链页面的话，记得还要按照“添加数据”这个步骤进行操作。&lt;/em>
总结一下，其实是官方文档没有提到需要创建 index.md 这一点坑了我，我还一直以为是我对文档的理解有误呢。&lt;/p>
&lt;h1 id="部署到github-pages">部署到Github Pages
&lt;/h1>&lt;h2 id="github上的准备">Github上的准备
&lt;/h2>&lt;p>这部分参考知乎专栏上的&lt;a class="link" href="https://zhuanlan.zhihu.com/p/35668237" target="_blank" rel="noopener"
>超详细Hexo+Github博客搭建小白教程&lt;/a>，打开&lt;a class="link" href="https://github.com" target="_blank" rel="noopener"
>github&lt;/a>并登录你的帐号，如果你还没在 github 帐号中添加 ssh key，请参考&lt;a class="link" href="https://gist.github.com/yisibl/8019693" target="_blank" rel="noopener"
>这篇文章&lt;/a>进行添加。接着点击右上角的个人头像，再点击 Your repositories：&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Use_GithubPages_and_Hexo_to_build_blog/go_to_repositories.png"
width="868"
height="402"
loading="lazy"
alt="进入项目页面"
class="gallery-image"
data-flex-grow="215"
data-flex-basis="518px"
>&lt;/p>
&lt;p>点击右侧的 New 新建项目。当然，你也可以直接点击&lt;a class="link" href="https://github.com/new" target="_blank" rel="noopener"
>这个链接&lt;/a>新建项目。输入自己的项目名字，后面一定要加.github.io 后缀，README 初始化也要勾上。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Use_GithubPages_and_Hexo_to_build_blog/new_repositories.png"
width="780"
height="616"
loading="lazy"
alt="新建项目"
class="gallery-image"
data-flex-grow="126"
data-flex-basis="303px"
>&lt;/p>
&lt;p>创建好项目后，点击 Settings，向下拉到最后有个 GitHub Pages，点击 Choose a theme 选择一个主题。然后等一会儿就可看到页面了。&lt;/p>
&lt;h2 id="正式部署到github-pages">正式部署到Github Pages
&lt;/h2>&lt;p>打开&lt;strong>站点配置文件&lt;/strong>，按以下示例进行修改：&lt;/p>
&lt;pre>&lt;code>deploy:
type: git
repository: 你的github项目地址
branch: master
&lt;/code>&lt;/pre>
&lt;p>repository 填写的应是类似于 &lt;a class="link" href="mailto:git@github.com" >git@github.com&lt;/a>:vifly/viflyblog.github.io.git 这样的 ssh 地址。假如你不知道地址，那么可以打开你在 github 上的这个项目，点击右侧的 Clone or download，就会出现所需的地址：&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Use_GithubPages_and_Hexo_to_build_blog/view_repositories_url.png"
width="1066"
height="463"
loading="lazy"
alt="查看项目ssh地址"
class="gallery-image"
data-flex-grow="230"
data-flex-basis="552px"
>&lt;/p>
&lt;p>最后，发布到 Github Pages：&lt;/p>
&lt;pre>&lt;code>hexo d
&lt;/code>&lt;/pre>
&lt;p>假如一直卡住的话，可中断后加上 -debug 参数再次运行这个部署指令，查看哪里出现问题。&lt;/p></description></item></channel></rss>