<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on Vifly 的博客</title><link>https://viflythink.com/tags/Linux/</link><description>Recent content in Linux on Vifly 的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 04 Sep 2021 00:00:00 +0800</lastBuildDate><atom:link href="https://viflythink.com/tags/Linux/atom.xml" rel="self" type="application/rss+xml"/><item><title>使用 Vercel 与 OneDrive 自建软件源</title><link>https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo/</link><pubDate>Sat, 04 Sep 2021 00:00:00 +0800</pubDate><guid>https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo/</guid><description>&lt;img src="https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo/show.jpg" alt="Featured image of post 使用 Vercel 与 OneDrive 自建软件源" />&lt;p>&lt;em>2021.11.12.更新：增加了关于 GPG 签名的说明。&lt;/em>&lt;/p>
&lt;p>大家好，又是本鸽子久违的博客更新。之前的&lt;a class="link" href="https://viflythink.com/Use_GitHubActions_to_build_AUR" target="_blank" rel="noopener"
>《GitHub Actions 打造 AUR 打包下载一条龙服务》&lt;/a>已经折腾出了完全白嫖的编译机，可好景不长，当我的机器数量变多后，我发现在每台机器上运行脚本下载软件包的确有点麻烦，与其自己写一个脚本下载软件包，还不如直接自建一个软件源呢。经过一番研究后，我盯上了 OneDrive 与 Vercel 这两个可以免费使用的服务，通过它们实现了自建一个完全免费而且在国内外都可高速访问的软件源。&lt;/p>
&lt;p>本文是对&lt;a class="link" href="https://viflythink.com/Use_GitHubActions_to_build_AUR" target="_blank" rel="noopener"
>《GitHub Actions 打造 AUR 打包下载一条龙服务》&lt;/a>的扩展，如果你还没有读过该博文，请先读完它再回来阅读本文。通过前文与本文，你可以在没有服务器，不花一分钱的情况下搭建一个基于 OneDrive 的高速自建软件仓库，体验到白嫖与折腾 Linux 的双重快乐。&lt;/p>
&lt;p>为了得到一个公开的软件仓库，只是把软件包构建出来并放到 GitHub Release 是不够的，没有软件包数据库，软件包管理器可不知道如何获取这些软件包，更不用提校验与安装等等。生成软件包数据库只需要一行 &lt;code>repo-add ./reponame.db.tar.gz *.tar.zst&lt;/code>，然后把它们都放到 GitHub Release 这样的免费存储后端就可以解决分发问题了，实际上有一个 &lt;a class="link" href="https://github.com/Brx86/repo" target="_blank" rel="noopener"
>arch-build 的 fork&lt;/a> 就是这样做的。当然，我对其还是不够满意，通过 fastgit 等 GitHub 反代服务的确可以加速 GitHub Release 的下载速度，但还是不够稳定；还有一个更重要的原因，我不仅想要自建 Arch 软件源，也想要自建 Debian 软件源，而 GitHub Release 的路径不够灵活，无法构造像 yourrepo.com/debian/pool/main/n/nginx/ 这样的 URL，没法满足自建 Debian 软件源的需求。所以嘛，只能自己再造一个轮子了。&lt;/p>
&lt;p>在看下文之前，不妨先打开&lt;a class="link" href="https://archrepo.viflythink.com/" target="_blank" rel="noopener"
>我的自建仓库&lt;/a>页面查看最终效果，如果想使用我的自建软件源，需要先执行以下指令导入 GPG 公钥：&lt;/p>
&lt;pre tabindex="0">&lt;code>wget -O /tmp/vifly-repo.key &amp;#39;https://share.viflythink.com/arch-repo.key&amp;#39; &amp;amp;&amp;amp; sudo pacman-key --add /tmp/vifly-repo.key
sudo pacman-key --lsign-key viflythink@gmail.com
&lt;/code>&lt;/pre>&lt;p>然后在 /etc/pacman.conf 末尾添加下面几行后执行 pacman -Syu：&lt;/p>
&lt;pre tabindex="0">&lt;code>[vifly]
Server = https://archrepo.viflythink.com
&lt;/code>&lt;/pre>&lt;p>尽管本文最终提供的成品目前只用在 Arch 自建源上，但对脚本稍加修改后也可以用来自建其它 Linux 发行版的软件仓库。&lt;/p>
&lt;h1 id="上传到-onedrive">上传到 OneDrive&lt;/h1>
&lt;p>之前配置的 GitHub Actions 已经可以把软件包上传到 Release 上，现在只需要对原来的配置文件稍加改造就可以让 GitHub Actions 把软件包也上传到 OneDrive，为了尽量不重复造轮子，在这里我选择了 Rclone 进行上传，它提供了非常完善的文件传输功能，例如上传或下载时遇到文件内容相同的情况会自动跳过。&lt;/p>
&lt;h2 id="在-azure-创建应用">在 Azure 创建应用&lt;/h2>
&lt;p>根据 &lt;a class="link" href="https://rclone.org/onedrive/#getting-your-own-client-id-and-key" target="_blank" rel="noopener"
>Rclone 的官方文档&lt;/a>操作即可，以下给出图文操作步骤。尽管 Rclone 官方认为这是可选的，但在 Vercel 部署直链下载应用时也需要在 Azure 创建应用获取 Token，所以便把相关步骤放这里了，另外基于权限最小化的原则，这里我们创建的是一个拥有读写权限的应用，而在 Vercel 部署时则是创建一个具有只读权限的应用，两个应用用在不同的地方，这样可有效提升安全性。&lt;/p>
&lt;p>打开 &lt;a class="link" href="https://portal.azure.com/#blade/Microsoft_AAD_RegisteredApps/ApplicationsListBlade" target="_blank" rel="noopener"
>Azure 的应用管理页面&lt;/a>，点击 New registration。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo/azure_applist.png"
width="1914"
height="786"
loading="lazy"
alt="Azure 应用列表"
class="gallery-image"
data-flex-grow="243"
data-flex-basis="584px"
>&lt;/p>
&lt;p>在打开的界面中输入应用的名字（这里我用了 rclone 这个名字），Supported account types 这一项选择 Accounts in any orGitHub Actionsnizational directory，在 Redirect URI (optional) 这一项选择 Web 并在右边的输入框里输入 http://localhost:53682/ 这一网址。完成后点击 Register。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo/azure_app_register.png"
width="1904"
height="878"
loading="lazy"
alt="Azure 注册应用"
class="gallery-image"
data-flex-grow="216"
data-flex-basis="520px"
>&lt;/p>
&lt;p>此时应用已经注册完成，记录下 Application (client) ID 的值，这就是下文会用到的 client id。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo/azure_get_client_id.png"
width="1918"
height="876"
loading="lazy"
alt="Azure 获取 client id"
class="gallery-image"
data-flex-grow="218"
data-flex-basis="525px"
>&lt;/p>
&lt;p>点击左侧菜单的 Certificates &amp;amp; secrets，然后点击 New client secret，在 Description 一栏随便填点什么，把 Expires（过期时间）设为最长的 24 months（两年后记得更新 client secret），点击 Add。最后记录下新增的 client secret 的值（在图中标注的 Value）。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo/azure_get_client_secret.png"
width="1918"
height="897"
loading="lazy"
alt="Azure 获取 client secret"
class="gallery-image"
data-flex-grow="213"
data-flex-basis="513px"
>&lt;/p>
&lt;p>到此为止就完成了。有些同学可能会感到奇怪：Rclone 文档中不是还有第 4 与第 5 步设置权限吗？根据我的实测，这两步并没有必要执行，所以这里不会附上这两步操作的示意图。&lt;/p>
&lt;h2 id="获取-token">获取 Token&lt;/h2>
&lt;p>在本地安装 Rclone（&lt;code>pacman -S rclone&lt;/code>），运行 rclone config 进入交互式配置流程，接着&lt;a class="link" href="https://rclone.org/onedrive" target="_blank" rel="noopener"
>一步步地按照提示操作&lt;/a>，当程序询问 Microsoft App Client Id 和 Microsoft App Client Secret 时，填入上一小节中记录的对应值。&lt;/p>
&lt;p>完成配置后 Rclone 会把配置数据存放在 ~/.config/rclone/rclone.conf，使用 &lt;code>cat ~/.config/rclone/rclone.conf&lt;/code> 查看。如下所示，下文需要复制对应的值时只需要把等号右边的东西按原样复制粘贴就行了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-INI" data-lang="INI">&lt;span class="line">&lt;span class="cl">&lt;span class="k">[xxx]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">type&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">onedrive&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">client_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">xxx&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">client_secret&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">xxx&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">region&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">global&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">drive_type&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">personal&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">token&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">{&amp;#34;access_token&amp;#34;:&amp;#34;xxx&amp;#34;,&amp;#34;token_type&amp;#34;:&amp;#34;Bearer&amp;#34;,&amp;#34;refresh_token&amp;#34;:&amp;#34;xxx&amp;#34;,&amp;#34;expiry&amp;#34;:&amp;#34;xxx&amp;#34;}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">drive_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">xxx&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;em>PS：一点安全提醒，在我们的用例中，client id 与 client secret 都可以公开，但 token 是绝对不能公开的。&lt;/em>&lt;/p>
&lt;h2 id="配置-github-actions">配置 GitHub Actions&lt;/h2>
&lt;p>首先 fork &lt;a class="link" href="https://github.com/vifly/arch-build" target="_blank" rel="noopener"
>arch-build 仓库&lt;/a>，如果你在之前已经使用了它，记得同步到最新版本。与前文所给的例子相比，现在的 workflow 文件（.github/workflows/build.yml）多了 uploadToOneDrive 这一个 job，而用到的 action 需要填入近十个参数，参数量的确很多，接下来让我介绍一下该如何填写这些参数。&lt;/p>
&lt;p>${{ secrets.xxx }} 这样的变量都是需要在 GitHub 的项目配置中的 Secrets 一栏设置的私密变量，打开项目的 Settings，找到下图所示的界面，然后点击 New repository secret，并填入 RCLONE_ONEDRIVE_CLIENT_ID、RCLONE_ONEDRIVE_CLIENT_SECRET、RCLONE_ONEDRIVE_TOKEN、RCLONE_ONEDRIVE_DRIVE_ID 这四个变量的值（从上一小节的 rclone.conf 中获得）。具体的操作也可参考 &lt;a class="link" href="https://docs.github.com/en/actions/reference/encrypted-secrets#creating-encrypted-secrets-for-a-repository" target="_blank" rel="noopener"
>GitHub 官方文档&lt;/a>。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo/github_actions_add_secret.png"
width="1868"
height="903"
loading="lazy"
alt="GitHub Actions 添加私密变量"
class="gallery-image"
data-flex-grow="206"
data-flex-basis="496px"
>&lt;/p>
&lt;p>接着回来修改 workflow 文件，RCLONE_ONEDRIVE_REGION 与 RCLONE_ONEDRIVE_DRIVE_TYPE 也是按 rclone.conf 的值填写；而 dest_path 是 OneDrive 上传的目的地路径（如果该路径不存在，Rclone 会自动创建），以 Linux 文件路径的形式填写即可，不建议使用根路径，因为接下来将会把这个路径下的所有东西公开，各位肯定不希望别人打开你的软件仓库页面时还看到其它乱七八糟的文件；repo_name 是你的自建软件仓库的名字，&lt;a class="link" href="https://wiki.archlinux.org/title/Pacman/Tips_and_tricks#Custom_local_repository" target="_blank" rel="noopener"
>它用于 repo-add 的参数&lt;/a>。&lt;/p>
&lt;p>为了安全，建议为自己的软件源添加 GPG 签名，不签名的话，pacman.conf 中的仓库配置需要加上 &lt;code>SigLevel = Never&lt;/code> 禁用签名校验才能使用。如果你想为自己的软件源添加 GPG 签名的话，建议先生成一个单独的 GPG 密钥对（不要设置密码），而不是使用原有的密钥对，并导出私钥：&lt;/p>
&lt;pre tabindex="0">&lt;code>gpg --gen-key
gpg --armor --export-secret-keys your_keyid &amp;gt; private.key
&lt;/code>&lt;/pre>&lt;p>回到 GitHub 的项目配置新增 Secrets，Name 为 gpg_private_key，Value 则是导出的私钥内容。最后在 workflow 文件的 uploadToOneDrive job 的参数加上 gpg-privatekey: ${{ secrets.gpg_private_key }}（即 dest_path、repo_name 等配置所在的位置）。现在得到的软件源将具有 GPG 签名，需要按以下步骤导入公钥才能使用：&lt;/p>
&lt;pre tabindex="0">&lt;code>gpg --armor --export your_keyid &amp;gt; public.key
sudo pacman-key --add public.key
sudo pacman-key --lsign-key your_keyid
&lt;/code>&lt;/pre>&lt;p>为了节省存储空间，这个 job 只会在 OneDrive 存储最新版本的软件包，不像 Arch 官方软件仓库那样还提供了归档。如果你对使用 Rclone 同步到 OneDrive 或构建软件包数据库的细节感兴趣，那么可以查看 &lt;a class="link" href="https://github.com/vifly/arch-build/blob/master/create-db-and-upload-action/entrypoint.sh" target="_blank" rel="noopener"
>entrypoint.sh&lt;/a> 脚本了解细节，不到三十行便完成了这些工作（其实是因为我把复杂的逻辑用 Python 实现了）。&lt;/p>
&lt;h1 id="在-vercel-部署直链下载应用">在 Vercel 部署直链下载应用&lt;/h1>
&lt;p>上面我们已经把软件包成功放到了 OneDrive 中，OneDrive 本身也有分享功能，可是它的分享链接地址没有任何的规律，Pacman 可不知道一个软件包对应的下载地址与 OneDrive 分享地址的联系，它只认 yourrepo.com/package 这样的下载地址（Apt 等包管理器认的 URL 更复杂，但依然有明显的规律），所以我们需要一个应用来实现链接的转换，这就是直链下载应用要干的事情。&lt;/p>
&lt;p>GitHub 上已经有不少 onedrive index 项目实现 OneDrive 的直链下载，我嫌它们提供的功能太多了（没忍住自造轮子的冲动），所以也用 Python 造了一个非常简陋的应用 &lt;a class="link" href="https://github.com/vifly/urepo" target="_blank" rel="noopener"
>urepo&lt;/a>，支持在 Vercel 上部署，也支持直接在 VPS 上部署，它和 Rclone 一样采用了微软官方提供的 API 实现提取文件下载链接的功能。下文将使用 urepo 实现直链下载，如果你之前已经部署了其它的 onedrive index 应用，那参照下文继续用原来的应用也是可以的。&lt;/p>
&lt;h2 id="获取访问令牌">获取访问令牌&lt;/h2>
&lt;p>既然 urepo 和 Rclone 一样采用了微软官方提供的 API，那么它同样也要像使用 Rclone 那样获取访问令牌。回到上面的“在 Azure 创建应用”这一小节，按同样的步骤再创建一个应用，只是这次的 Redirect URI (optional) 应输入 http://localhost/ ，完成后得到 client id 与 client secret。&lt;/p>
&lt;p>与上面依靠 Rclone 获取 Token 不同的是，这次则是使用一个脚本获取 Token，它不会像 Rclone 那样申请写入权限。下载我写好的&lt;a class="link" href="https://github.com/vifly/urepo/blob/main/client-tools/get_deploy_config.py" target="_blank" rel="noopener"
>获取 Token 脚本&lt;/a>与&lt;a class="link" href="https://github.com/vifly/urepo/blob/main/client-tools/config.py.example" target="_blank" rel="noopener"
>配置示例&lt;/a>，并确保已经安装了 Python 的 Requests 库（&lt;code>pacman -S python-requests&lt;/code>），然后把配置示例（config.py.example）重命名为 config.py，并填入 CLITENT_ID 与 CLITENT_SECRET。&lt;/p>
&lt;p>运行脚本：&lt;/p>
&lt;pre tabindex="0">&lt;code>cd downloadpath
python3 get_deploy_config.py
&lt;/code>&lt;/pre>&lt;p>根据提示操作，最后得到 code 与 refresh_token。此时我们已经获得 client id、client secret、code、refresh_token 这四项配置。至于下文中需要用到的 path，那就是在“配置 GitHub Actions”这一小节中的 dest_path。&lt;/p>
&lt;h2 id="部署到-vercel">部署到 Vercel&lt;/h2>
&lt;p>&lt;a class="link" href="https://vercel.com/" target="_blank" rel="noopener"
>Vercel&lt;/a> 是一个免费的应用部署平台，主要用来测试和部署 Serverless 应用，通过它，我们可以零成本地部署直链下载应用。Vercel 提供了两种部署方式，从下面两种方式任选其一执行即可。&lt;/p>
&lt;h3 id="打开链接部署推荐">打开链接部署（推荐）&lt;/h3>
&lt;p>注册或登录你的 Vercel 账号，然后打开我创建的&lt;a class="link" href="https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fvifly%2Furepo&amp;amp;env=code,path,client_secret,client_id,refresh_token" target="_blank" rel="noopener"
>部署链接&lt;/a>，会出现如下界面，在 GitHub、GitLab、Bitbucket 这三个 Git 平台中选择一个进行连接，Vercel 会把 urepo 仓库复制到连接的平台上。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo/vercel_import_repo.png"
width="1204"
height="893"
loading="lazy"
alt="Vercel 导入仓库"
class="gallery-image"
data-flex-grow="134"
data-flex-basis="323px"
>&lt;/p>
&lt;p>接下来的 Create a Team 只要点击 Skip 跳过就行，然后就是环境变量的设置，urepo 会首先尝试从环境变量中读取这些私密信息，无法找到对应的信息时才会去读取项目根目录下的 auth.json 获取配置，与把访问令牌写在配置文件相比，利用环境变量配置可以避免自己不小心把私密信息公开，根据上文填写这五个环境变量后就完成部署了。&lt;/p>
&lt;h3 id="从本地上传部署">从本地上传部署&lt;/h3>
&lt;p>本方法需要安装 NodeJS 相关的工具链，我不太想和这些工具打交道，但 Vercel 本来是一个部署前端应用的平台，所以官方的客户端使用 JS 编写是很正常的事情，如果不想安装这些软件，那可以使用上面的部署方法。&lt;/p>
&lt;p>首先安装 Yarn 或其它 NodeJS 包管理器：&lt;code>pacman -S yarn&lt;/code>，由于 JS 应用总是喜欢在用户的家目录乱丢东西，所以为了让 Yarn 遵循&lt;a class="link" href="https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html" target="_blank" rel="noopener"
> XDG 目录规范&lt;/a>，我们可以执行 &lt;code>yarn config set prefix ~/.local&lt;/code>。然后执行下面的指令全局安装 vercel 应用，这会把它安装到你的家目录（~/.local/bin，记得让你的 $PATH 包含这个路径）：&lt;/p>
&lt;pre tabindex="0">&lt;code>yarn global add vercel
&lt;/code>&lt;/pre>&lt;p>安装完成后执行下面的指令进行登录，在打开的浏览器窗口注册或登录你的 Vercel 账号并进行验证：&lt;/p>
&lt;pre tabindex="0">&lt;code>vercel login
&lt;/code>&lt;/pre>&lt;p>下载 urepo 源码：&lt;/p>
&lt;pre tabindex="0">&lt;code>git clone git@github.com:vifly/urepo.git
&lt;/code>&lt;/pre>&lt;p>把 urepo 根目录下的 auth.json.example 重命名为 auth.json，然后把对应的配置填入里面。或者，也可以在上传部署后到 Vercel 的项目面板中设置 code、path、client_secret、client_id、refresh_token 这五个环境变量。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo/vercel_set_env.png"
width="1236"
height="902"
loading="lazy"
alt="Vercel 设置环境变量"
class="gallery-image"
data-flex-grow="137"
data-flex-basis="328px"
>&lt;/p>
&lt;p>最后就是上传部署：&lt;/p>
&lt;pre tabindex="0">&lt;code>cd urepo
vercel .
&lt;/code>&lt;/pre>&lt;h2 id="使用自己的域名可选">使用自己的域名（可选）&lt;/h2>
&lt;p>尽管 Vercel 会为部署的应用分配一个二级域名（xxx.vercel.app），但自建源使用自己的域名无疑是一个更好的选择。根据&lt;a class="link" href="https://vercel.com/docs/custom-domains#subdomains" target="_blank" rel="noopener"
>官方文档&lt;/a>，首先需要打开项目的域名管理界面，添加自己想使用的域名。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo/vercel_add_domain.png"
width="1319"
height="873"
loading="lazy"
alt="Vercel 添加域名"
class="gallery-image"
data-flex-grow="151"
data-flex-basis="362px"
>&lt;/p>
&lt;p>假设各位和我一样使用了自己的子域名，那么在自己的 DNS 解析服务提供商管理面板添加一条 CNAME 解析记录即可，我使用的是 cloudflare，还需要把代理状态设为“仅限 DNS”以确保不会使用 cloudflare 的反代。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo/cloudflare_set_vercel_cname.png"
width="1102"
height="154"
loading="lazy"
alt="在 cloudflare 设置指向 Vercel 的 CNAME"
class="gallery-image"
data-flex-grow="715"
data-flex-basis="1717px"
>&lt;/p>
&lt;h1 id="有待改进的地方">有待改进的地方&lt;/h1>
&lt;p>尽管这一流程已经能工作了，但有些地方还是可以再改进一下的。&lt;del>首先，目前并没有数字签名，添加这一自建软件源时需要禁用对此的签名校验，在乎安全性的同学可能会对此表示不爽，所以日后有必要加上对软件包签名的支持。其次，urepo 应该无需修改就可以用于分发其它发行版的软件包与数据库（它的本质就是一个简陋的 onedrive index），但前面的 GitHub Actions 只支持 Arch，我未来肯定会加上对 Debian/Ubuntu 的支持，具体什么时候搞定这个，就要看我什么时候有需求了，对其它发行版的支持也是同样的😂&lt;/del>。目前已支持 GPG 签名，也新增了 &lt;a class="link" href="https://github.com/vifly/debian-build" target="_blank" rel="noopener"
>debian-build&lt;/a> 用于构建 deb 软件包。&lt;/p>
&lt;p>另外，我编写的 urepo 与 GitHub Actions 脚本的报错信息并不够用户友好，由于大量采用了 Python 进行编写，假如出现错误的话对于没学过 Python 的同学来说可能难以根据输出的错误信息解决问题。这个问题也是留待日后解决。&lt;/p></description></item><item><title>GitHub Actions 打造 AUR 打包下载一条龙服务</title><link>https://viflythink.com/Use_GitHubActions_to_build_AUR/</link><pubDate>Tue, 28 Apr 2020 00:00:00 +0800</pubDate><guid>https://viflythink.com/Use_GitHubActions_to_build_AUR/</guid><description>&lt;img src="https://viflythink.com/Use_GitHubActions_to_build_AUR/show.png" alt="Featured image of post GitHub Actions 打造 AUR 打包下载一条龙服务" />&lt;p>&lt;em>2021.2.2.更新：受 &lt;a class="link" href="https://www.aloxaf.com/2020/06/build_aur_with_github_actions/" target="_blank" rel="noopener"
>Aloxaf 的博文&lt;/a>启发新增使用自己的 PKGBUILD 进行构建的说明。&lt;/em>&lt;/p>
&lt;p>尽管目前博主我还在考研，但最近还是经不住折腾 Arch 的诱惑，抽空对使用 Arch 以来一直觉得体验不够好的安装 AUR 软件包流程进行改造，最终的结果就是搭建了这一个自动化的 AUR 编译打包下载安装一条龙服务，并写下本文向各位安利。要问为什么我想折腾这个东西，当然是因为使用 AUR 助手安装 AUR 的软件包存在如下缺点：&lt;/p>
&lt;ol>
&lt;li>下载速度慢，由于很多时候都需要从 GitHub 下载文件，所以每秒 10 KB 的下载速度是很常见的（虽然这点可以通过设置 http_proxy 环境变量让 Yay 等 AUR 助手使用代理来解决）&lt;/li>
&lt;li>编译需要时间，如果你只是需要几个小软件包那可以无视这点&lt;/li>
&lt;li>给别人分享已打好的软件包有点麻烦，每次更新你都需要通过某种方式传输文件给对方（凑够三点 ／人◕‿‿◕人＼）&lt;/li>
&lt;/ol>
&lt;p>为了解决以上问题，本文使用免费的 GitHub Actions 与 Cloudflare Workers，手把手教你搭建一个自动化 AUR 软件构建流程，只需一次配置，你就可以享受船新的&lt;del>白嫖&lt;/del> AUR 使用体验。另外，这也是我第一次实际使用 CI（持续集成），通过配置整个工作流，我算是学习了一把 CI 的使用（&lt;em>PS：这才是真正的目的&lt;/em>），所以你也可以把这篇文章当作我的 CI 学习笔记。&lt;/p>
&lt;h1 id="github-actions-简介">GitHub Actions 简介&lt;/h1>
&lt;p>首先，GitHub Actions 是 GitHub 在 2019 年推出的一项 CI 服务。如果你没听说过 CI，那这里我尝试用一句话来解释，CI 就是对新的项目更改进行自动化构建，在本文的场景下，新的更改指的是 AUR 上的 PKGBUILD 文件发生变更（实际上我为了偷懒，选择了设置定时任务而不是监测 PKGBUILD 的变更），自动化构建就是自动编译加打包以及上传（如果是闭源软件那就不是编译而是拆包等操作）。嗯，就是这么简单，如果想知道 CI 的详细定义，可以看下&lt;a class="link" href="https://www.redhat.com/zh/topics/devops/what-is-ci-cd" target="_blank" rel="noopener"
>红帽的文章&lt;/a>。&lt;/p>
&lt;p>GitHub Actions 的特点是支持的触发条件种类数非常多，而且与 GitHub 的集成很好，学习难度也不高，只要简单地写一个配置文件即可，还可轻松调用别人写好的操作步骤，对于开源项目作者来说最大的好处就是可以白嫖 GitHub 的机器用来为不同的平台编译。如果你已经对 GitHub Actions 感到心动，那么不妨阅读&lt;a class="link" href="https://help.github.com/en/actions/getting-started-with-github-actions" target="_blank" rel="noopener"
>官方文档&lt;/a>来学习一下用法，或者靠&lt;a class="link" href="https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" target="_blank" rel="noopener"
>阮一峰的介绍文&lt;/a>快速上手。想要更简短的介绍？没问题，来看看下面的讲解吧。&lt;/p>
&lt;p>想要使用 GitHub Actions，那首先需要在项目根目录下的 .github/workflows 文件夹下创建一个以 yml 为后缀名的 workflow 文件（如 build.yml），在这个 YAML 文件中写入我们的配置。那么配置该怎么写呢，让我们看一个示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-YAML" data-lang="YAML">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Greeting from Mona&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">push&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">jobs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># ================== 第一个 job，这只有一个 job ==================&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">my-job&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">My Job&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">runs-on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ubuntu-latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">steps&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># ================== 第一个 step，执行单个命令 ==================&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Print a greeting&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">env&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">MY_VAR&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Hi there! My name is&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">FIRST_NAME&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Mona&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">MIDDLE_NAME&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">The&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">LAST_NAME&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Octocat&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># ================== 第二个 step，使用别人的 action ==================&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">actions/checkout@v2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># ================== 第三个 step，执行多个命令 ==================&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Install the dependencies&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">|&lt;/span>&lt;span class="sd">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="sd"> sudo apt-get update
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="sd"> sudo apt-get install pkg-config gettext&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>按从上到下的顺序来看，name 对象应该无需解释了，值得注意的是 &lt;a class="link" href="https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#on" target="_blank" rel="noopener"
>on&lt;/a> 对象，可以填入单个事件或事件数组作为触发条件，当满足条件时便执行这个 YAML 文件里的内容（一个项目可以存在多个 workflow 文件），在示例中的 push 指的是 git push，即每次推送代码都会触发这个 workflow，完整的事件支持列表可通过&lt;a class="link" href="https://help.github.com/en/articles/events-that-trigger-workflows" target="_blank" rel="noopener"
>官方文档&lt;/a>获知。&lt;/p>
&lt;p>接下来就是 jobs 了，在这里我们只创建了一个名为 my-job 的 job，一般而言 jobs 是 workflow 文件的主体，一个 job 由若干个 step 组成，这些 step 会按顺序执行，为了便于阅读，我用分割线将各个 step 分开了。&lt;/p>
&lt;p>在解释 step 前我们不妨先看下每一个 job 中都要填写的 &lt;a class="link" href="https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on" target="_blank" rel="noopener"
>runs-on&lt;/a> 对象，它指定了该 job 的工作系统环境，目前可选的系统有 windows-latest、ubuntu-latest、ubuntu-16.04、macos-latest，这覆盖了主流的操作系统平台，为不同平台的编译提供了便利。&lt;/p>
&lt;p>最后，就是每个 job 中必须存在的 step 了，每个 step 都代表一个单独的操作步骤，既可以在 &lt;a class="link" href="https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idstepsrun" target="_blank" rel="noopener"
>run&lt;/a> 对象内填入你需要执行的 Shell 命令，也可以在 &lt;a class="link" href="https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idstepsuses" target="_blank" rel="noopener"
>uses&lt;/a> 对象里填入对应的配置以使用别人的 action（在 &lt;a class="link" href="https://github.com/marketplace?type=actions" target="_blank" rel="noopener"
>Marketplace&lt;/a> 中浏览全部 action）。&lt;a class="link" href="https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idstepsenv" target="_blank" rel="noopener"
>env&lt;/a> 对象用来设置环境变量，这个对象存在一个非常有趣的应用场景：如果你的 step 需要使用不宜公开的 Token，那你可以&lt;a class="link" href="https://help.github.com/en/actions/configuring-and-managing-workflows/creating-and-storing-encrypted-secrets" target="_blank" rel="noopener"
>在项目设置中设置该 Token&lt;/a>，然后在 env 对象中使用 super_secret: $ 将这个 Token 设为一个环境变量，并在自己的 step 中读取该环境变量以取得 Token，这样就能避免在 workflow 文件中硬编码 Token。当你再次看到 $ 这样的变量时，你就应该明白这是一个私密变量，是不能公开的。&lt;/p>
&lt;h1 id="开始构造打包工作流">开始构造打包工作流&lt;/h1>
&lt;p>经过上文的介绍，各位应该对 GitHub Actions 有了一定的了解，接下来就让我们开始白嫖 GitHub Actions 吧。注意，本节中的说明均与最新版本的 &lt;a class="link" href="https://github.com/vifly/arch-build" target="_blank" rel="noopener"
>arch-build&lt;/a> 存在差异，仅用作描述思路，想要抄作业的请直接跳到“最终成品与配置”一节。&lt;/p>
&lt;h2 id="自动编译-aur-的软件包">自动编译 AUR 的软件包&lt;/h2>
&lt;p>一般而言，我们都是在 Arch Linux 上构建 AUR 上的软件包，但是上文提到的 runs-on 对象可以填入的系统并不包括 Arch，那该怎么办呢？答案是使用基于 Arch 的容器，在容器内构建。这里要感谢 &lt;a class="link" href="https://github.com/Qv2ray/Qv2ray" target="_blank" rel="noopener"
>Qv2ray&lt;/a> 的一位开发者 &lt;a class="link" href="https://www.ducksoft.site/" target="_blank" rel="noopener"
>DuckSoft&lt;/a> 提供了这个思路，而且编写了 &lt;a class="link" href="https://github.com/DuckSoft/build-aur-action" target="_blank" rel="noopener"
>build-aur-action&lt;/a> 这个 action 用来编译打包 AUR 上的软件。现在，我们需要考虑的就是如何自动进行编译，从 CI 的正常使用方式来说，我们应该在 on 对象中设定这样一个触发条件：当 AUR 特定的软件包更新时自动进行编译。不过这个方案还需要写检测更新的代码，为了偷懒，我选择设置定时任务来编译，由于 on 对象支持&lt;a class="link" href="https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#onschedule" target="_blank" rel="noopener"
>通过 Cron 语法设定定时任务&lt;/a>，所以这个问题能被轻松解决。就这样，我们完成了一个简单的 workflow 文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-YAML" data-lang="YAML">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">BUILD&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">schedule&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">cron&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;1 */8 * * *&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">jobs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">build&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">runs-on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ubuntu-latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">steps&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">DuckSoft/build-aur-action@master&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">repo-name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">osu-lazer&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>提醒一下，使用别人的 action 时可能需要使用 with 对象输入一些变量，在这里我们输入的就是想要构建的 AUR 软件的软件包名。&lt;/p>
&lt;h2 id="上传到-github-releases">上传到 GitHub Releases&lt;/h2>
&lt;p>在上一步中我们已成功地构建了想要的软件包，接下来需要解决的就是如何把软件包取出来这个问题了。最好的解决方案莫过于将构建出来的软件包上传到 Releases，GitHub 官方提供了 &lt;a class="link" href="https://github.com/actions/upload-release-asset" target="_blank" rel="noopener"
>upload-release-asset&lt;/a> 来完成这个操作，但我看了说明文档后觉得这个太麻烦了，它不支持通过 Unix 终端规则（例如 “*.zst”）筛选要上传的文件，而且需要先创建 Releases 后才能上传文件。经过一番谷歌，我找到了 &lt;a class="link" href="https://github.com/ncipollo/release-action" target="_blank" rel="noopener"
>release-action&lt;/a> 这个替代品，与 upload-release-asset 相比，这个 action 的配置明显更简单，从下面这段配置即可看得出来：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-YAML" data-lang="YAML">&lt;span class="line">&lt;span class="cl">- &lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ncipollo/release-action@v1.7.3&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">allowUpdates&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">tag&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;packages&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">artifacts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;./*/*.zst&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">token&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${{ secrets.GITHUB_TOKEN }}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>把这段配置添加到 workflow 中，然后我们先看看 with 对象中输入的变量。token 是上传文件到 Releases 时必需的一项变量，从它的形式就可以看出这是一个私密变量，不过这个私密变量是内置的，我们不需要在项目中手动设置这个变量，直接使用即可；接着就是 tag 了，为了方便管理，我们在仓库的 Releases 页面创建一个 tag，然后将 tag 的名字填入其中。完成配置后这个 action 就会把构建的软件包上传到指定 tag 下的 Releases，我们也可以下载该软件包了。&lt;/p>
&lt;h2 id="使用-matrix-进行改进">使用 matrix 进行改进&lt;/h2>
&lt;p>虽然目前我们的 workflow 已经能用了，但是需要编译多个 AUR 的软件时需要多次复制粘贴上面的 step，这可太难看了，是否存在更优雅的方法呢？答案是有的，经 DuckSoft 的提醒，可以使用 &lt;a class="link" href="https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idstrategymatrix" target="_blank" rel="noopener"
>matrix&lt;/a>，它基于单个 job 中定义的 steps 并行运行多个 job，多个 job 之间的差异就是特定变量的差异，这些变量以数组的形式存在。一般来说，matrix 的用处就是为不同平台采取同样的步骤进行构建，在本文的场景下就是采用同样的步骤构建不同的 AUR 软件。虽然听着有点抽象，但看一下这个例子你就应该能明白了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-YAML" data-lang="YAML">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">jobs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">build&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">strategy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">matrix&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">repos&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="l">osu-lazer, mpv-mpris]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">fail-fast&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">runs-on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ubuntu-latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">steps&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">DuckSoft/build-aur-action@master&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">repo-name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${{ matrix.repos }}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>与之前的 workflow 不同，我们先创建了 repos 数组，并在其中填入需要构建的软件名。如果不把 fail-fast 设置为 false，在并行 job 中出现一个运行失败的 job 时会导致其它的 job 被终止。另外，使用 build-aur-action 时我们没有直接输入 repo-name，而是以 $ 的形式输入，数组中的变量会自动应用到对应的 job 中。&lt;/p>
&lt;h2 id="使用自己的-pkgbuild可选">使用自己的 PKGBUILD（可选）&lt;/h2>
&lt;p>上述版本已经很完美了，不过还存在一个问题：我需要的某个软件包虽然在 AUR 中存在，但对应的 PKGBUILD 写的太烂了/无法构建成功，此时我写了一个 PKGBUILD，希望能白嫖 GitHub Actions 进行构建，该怎么办呢。这个需求也是早有人想到了，只需使用 &lt;a class="link" href="https://github.com/edlanglois/pkgbuild-action" target="_blank" rel="noopener"
>pkgbuild-action&lt;/a> 就可解决，它还可以解决打的包还依赖了其它的 AUR 包的问题。为此，我们需要再添加一个 job，checkout 目前仓库获取 PKGBUILD，然后使用 pkgbuild-action 进行构建，需要的 pkgdir 参数就是 PKGBUILD 所在的路径（父文件夹），最后依然是使用 release-action 根据 pkgbuild-action 返回的构建产物路径将其上传到 GitHub Releases。&lt;/p>
&lt;h1 id="最终成品与配置">最终成品与配置&lt;/h1>
&lt;p>最终版的 workflow 可以在&lt;a class="link" href="https://github.com/vifly/arch-build/blob/master/.github/workflows/build.yml" target="_blank" rel="noopener"
>这&lt;/a>查看，只需 fork &lt;a class="link" href="https://github.com/vifly/arch-build" target="_blank" rel="noopener"
>arch-build&lt;/a>，然后按下面的说明修改一下 workflow 文件即可食用。注意，经过一段时间的改进，最终版的配置已与上文存在一定区别，其中的 uploadToOneDrive 是&lt;a class="link" href="https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo" target="_blank" rel="noopener"
>《使用 Vercel 与 OneDrive 自建软件源》&lt;/a>中所需的 job，如果你不需要建立一个可公共访问的软件源请删掉它。&lt;/p>
&lt;p>如果只是需要构建上传 AUR 包，那只需修改 buildAUR 这个 job 中的内容，根据自己的需要修改其 matrix 内的软件包名，buildNonAUR 的内容则可以删掉。&lt;/p>
&lt;p>如果想使用自己的 PKGBUILD 进行构建，那还需要修改 buildNonAUR 这个 job，依然需要修改其 matrix 内的软件包名，另外还需要在仓库的根目录下新建以软件包名命名的文件夹，在其中存放对应的 PKGBUILD 文件和其它构建过程中所需的资源文件。经过我的修改后的 pkgbuild-action 还支持一个新功能：如果想构建的软件包依赖某个 AUR 软件包而你不想使用 AUR 上的 PKGBUILD，那么你可以新建一个子文件夹，在其中放入自己的 PKGBUILD。结构如下所示：&lt;/p>
&lt;pre tabindex="0">&lt;code>├── foo
│   ├── PKGBUILD
│   └── bar (dependences of foo)
│   ├── PKGBUILD
│   └── baz (dependences of bar)
│   └── PKGBUILD
&lt;/code>&lt;/pre>&lt;p>到此为止，借助 GitHub Actions，我们拥有了一个 24 小时可用的编译机以及公开的软件包存储库，解决了本文开始提到的第二与第三点问题。这些都是全自动且免费的，为了更好的体验，下文将介绍如何让安装软件包也实现自动化。&lt;/p>
&lt;h1 id="简单的自动更新仓库">简单的自动更新仓库&lt;/h1>
&lt;p>打开浏览器，从 Releases 页面下载软件包，然后执行 pacman -U xxx.pkg.tar.zst 安装软件包，这些操作实在太麻烦了，为何不建立一个软件源，令每次执行 pacman -Syu 时自动安装最新版本的软件呢。自建软件源听上去十分高大上，但其实只是建立一个本地软件源并不难，&lt;a class="link" href="https://wiki.archlinux.org/index.php/Pacman/Tips_and_tricks#Custom_local_repository" target="_blank" rel="noopener"
>Arch WiKi 几段文字&lt;/a>便说明白了，当然，如果想建立一个在线的公用软件源会麻烦一些，所以这里只说明如何建立一个自动更新的本地软件源。想要建立公用软件源的话请跳过下文，阅读我的新博文&lt;a class="link" href="https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo" target="_blank" rel="noopener"
>《使用 Vercel 与 OneDrive 自建软件源》&lt;/a>。&lt;/p>
&lt;h2 id="使用自动化脚本">使用自动化脚本&lt;/h2>
&lt;p>作为一个爱偷懒的人，我肯定希望能自动化下载软件包与更新软件仓库的操作，为此我写了一个脚本来完成这些事情，各位只需打开&lt;a class="link" href="https://github.com/vifly/helper" target="_blank" rel="noopener"
>项目地址&lt;/a>，下载代码并根据说明进行操作即可。我在这里说明一下 conf.py 的配置：UserName 和 GitHubRepoName 并不难理解，举个例子，我的白嫖仓库地址是 &lt;a class="link" href="https://github.com/vifly/arch-build" target="_blank" rel="noopener"
>https://github.com/vifly/arch-build&lt;/a> ，那么需要填写的 UserName 便是 vifly，GitHubRepoName 则是 arch-build；ProxyURL 在下一小节会提到，这里先不说；DownloadPath 是从 Releases 下载的软件包的存储路径；末尾的 ArchRepoDBPath 和 ArchRepoName 是用于生成本地软件源的数据库的，脚本会调用 repo-add 根据 DownloadPath 中的软件包生成路径为 ArchRepoDBPath/ArchRepoName.db.tar.gz 的数据库。&lt;br>
当你成功运行脚本建立了一个本地软件源后，还需要修改 /etc/pacman.conf 文件，在末尾添加以下配置以让 Pacman 同步你的软件源的数据库（自行替换 ArchRepoName 与 ArchRepoDBPath）：&lt;/p>
&lt;pre>&lt;code>[ArchRepoName]
SigLevel = Optional TrustAll
Server = file://ArchRepoDBPath
&lt;/code>&lt;/pre>
&lt;p>另外，为了让本地的软件仓库保持最新，我们可以通过 &lt;a class="link" href="https://wiki.archlinux.org/index.php/cron" target="_blank" rel="noopener"
>Cron&lt;/a> 设置一个定时任务自动运行这个脚本。现在，我们得到了一个完全免费、自动更新的个人软件仓库，快执行 pacman -Syu 开始享受白嫖的快乐吧。&lt;/p>
&lt;h2 id="使用-cloudflare-workers-反代加速下载可选">使用 Cloudflare Workers 反代加速下载（可选）&lt;/h2>
&lt;p>为了解决在国内 GitHub 下载速度慢的问题，让我们继续发扬白嫖的精神，使用 &lt;a class="link" href="https://workers.cloudflare.com/" target="_blank" rel="noopener"
>Cloudflare Workers&lt;/a>（不需要拥有域名） 来加快下载速度。广大白嫖党早已发现可以使用免费的 Cloudflare Workers 部署 serverless 应用反代国内无法访问的网络资源，在这里我们也使用这种方式加速下载。刚开始时我使用了 &lt;a class="link" href="https://github.com/hunshcn/gh-proxy" target="_blank" rel="noopener"
>gh-proxy&lt;/a> 这个加速 GitHub 下载的项目，不过后来 Arch 群的 &lt;a class="link" href="https://nichi.co/" target="_blank" rel="noopener"
>NickCao&lt;/a> 同学推荐了他写的更通用的反代应用，感谢 NickCao，接下来我们便开始部署反代应用吧。 &lt;br>
首先，打开&lt;a class="link" href="https://workers.cloudflare.com/" target="_blank" rel="noopener"
>官网&lt;/a>，注册或登录你的 Cloudflare 帐号，点击 Start building，选择免费方案并创建一个专属的子域名（是 workers.dev 的子域名），进入主页后点击 Create a Worker，复制&lt;a class="link" href="https://gitlab.com/NickCao/experiments/-/blob/master/workers/r.js" target="_blank" rel="noopener"
>这份代码&lt;/a>，像下图这样粘贴到编辑框内：&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Use_GitHubActions_to_build_AUR/create_cloudflare_workers.png"
width="1918"
height="835"
loading="lazy"
alt="创建 Cloudflare Workers 应用"
class="gallery-image"
data-flex-grow="229"
data-flex-basis="551px"
>&lt;/p>
&lt;p>注意，页面中间的域名是 Cloudflare Workers 分配给你的一个专属子域名（形如 xxx.xxx.workers.dev），复制这个域名并用它替换左侧代码中的两处域名，完成修改后点击 Save and Deploy 保存并部署，这样我们就得到了一个可以反代网络资源的应用了。&lt;/p>
&lt;p>最后，还记得在上一小节中被忽略的 ProxyURL 配置项吗，这里各位只需填入刚刚得到的 xxx.xxx.workers.dev 域名就可以了，脚本会使用这个反代域名高速下载 GitHub Releases 的软件包。&lt;/p></description></item><item><title>将 KDE 改造为 Windows 10</title><link>https://viflythink.com/KDE_to_Windows10/</link><pubDate>Wed, 01 Jan 2020 10:08:32 +0800</pubDate><guid>https://viflythink.com/KDE_to_Windows10/</guid><description>&lt;img src="https://viflythink.com/KDE_to_Windows10/show.jpg" alt="Featured image of post 将 KDE 改造为 Windows 10" />&lt;p>&lt;em>2023.6.18.更新：为适配新版本的 KDE 以及找到了更好的方案，本文大部分内容已被更新。注意旧的一些配图依然有所保留，所以不要对截图风格不统一感到奇怪。&lt;/em>&lt;/p>
&lt;p>2020 年已然到来，一些博主已经发表了年度总结，总结了不少经验，我想了想，觉得自己好像没什么可以总结的经验，只好写一篇最近的 KDE 折腾记录给各位读者当新年礼物了。想必有不少刚开始使用 Linux 的新手总想着美化自己的桌面吧，我在开始使用 KDE 后也想着折腾美化，随便搜索了一下美化教程后发现不少都是将 KDE 改造为 Mac 风格的，之前听闻 KDE 粉说过“你可以将 KDE 捏成任何形状”，然而很多人都是将它捏成 Mac 的样子，那么，能把 KDE 捏成 win10 的形状吗？我决定挑战一下这个问题，当然，在这里我要承认这有点标题党的嫌疑，我只是想将我认为 win10 做得好的部分转嫁到 KDE 上，并不是将 KDE 完全变为 win10 的样子，后者是一件费力不讨好的事情，而且，在经过一波折腾后，我发现有些细节还暂时无法做到像 win10 那样优秀，只能寄希望于未来了。另外，本文只适用于 Arch，我尚未在其它发行版进行测试。&lt;/p>
&lt;p>先上一张图片看看改造后的效果（图中标注了下文用到的名词所指代的东西）：&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/KDE_to_Windows10/my_kde_desktop.png"
width="1920"
height="1080"
loading="lazy"
alt="我的桌面展示"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="426px"
>&lt;/p>
&lt;p>觉得很漂亮吧？那么，接下来就开始我们的改造吧。&lt;/p>
&lt;h1 id="底部栏">底部栏&lt;/h1>
&lt;p>在没有打开任何窗口时，底部栏是与 win10 相差最远的一个地方，所以我们的改造工作先从底部栏开始。可以先看看改造完成后的底部栏效果图：&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/KDE_to_Windows10/my_bottom.png"
width="2558"
height="52"
loading="lazy"
alt="底部栏"
class="gallery-image"
data-flex-grow="4919"
data-flex-basis="11806px"
>&lt;/p>
&lt;h2 id="开始菜单">开始菜单&lt;/h2>
&lt;p>喜欢 win10 那简洁的开始菜单吗，在 KDE 下只需安装一个挂件（widgets）即可拥有同样的体验。下载 &lt;a class="link" href="https://store.kde.org/p/1160672/" target="_blank" rel="noopener"
>Tiled Menu&lt;/a>，并在底部栏空白处单击右键，然后点击“添加挂件”，按照下图所示进行安装。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/KDE_to_Windows10/install_widget.png"
width="288"
height="880"
loading="lazy"
alt="安装挂件"
class="gallery-image"
data-flex-grow="32"
data-flex-basis="78px"
>&lt;/p>
&lt;p>想要使用的话有两种方法：在你左下角的开始菜单处鼠标右键单击，选择“显示替代方案”，选择 Tiled Menu；在底部栏右键单击，选择“编辑面板”，鼠标移到原来的开始菜单，选择移除，然后选择“添加挂件”，选择 Tiled Menu。你可以在弹出的开始菜单右上角按住 ALT 和 鼠标右键进行拖拽以更改菜单大小。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/KDE_to_Windows10/set_start_menu.png"
width="1920"
height="232"
loading="lazy"
alt="将 Tiled Menu 设为开始菜单"
class="gallery-image"
data-flex-grow="827"
data-flex-basis="1986px"
>&lt;/p>
&lt;h2 id="任务管理器挂件">任务管理器挂件&lt;/h2>
&lt;p>依然是在底部栏右键单击，选择“编辑面板”，将鼠标移动到底部栏空白处，点击“显示替代方案”，选择图标任务管理器（Icon-Only Task Manager），然后你就可以看到类似于 win10 的底部窗口了，这里说明一下，图标任务管理器是自带的一个挂件，无需安装。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/KDE_to_Windows10/set_task_manager.png"
width="1920"
height="250"
loading="lazy"
alt="设置图标任务管理器"
class="gallery-image"
data-flex-grow="768"
data-flex-basis="1843px"
>&lt;/p>
&lt;h2 id="快速查看已打开的窗口">快速查看已打开的窗口&lt;/h2>
&lt;p>win10 可点击左下角的按钮快速查看已打开的窗口，在安装了 &lt;a class="link" href="https://store.kde.org/p/1181039" target="_blank" rel="noopener"
>Present Windows Button&lt;/a> 这个挂件后，我们也可以做到这一点。这个挂件的安装方法与 Tiled Menu 时相同，在安装完成后把这个挂件放在开始菜单和任务管理器之间。这个挂件产生的点击效果与在 Gnome 下将鼠标移动到屏幕左上角触发的效果差不多，KDE 也可设置这样的触发角，不过我觉得设置这样的一个按钮没什么实际意义，可能最大的好处就是没事点一下能有效消遣无聊吧（雾）。这里还有一个能让底部栏变得更美观的 Tips，在底部栏右键单击，选择“编辑面板”后点击“添加间距”，以此添加两个间距，将其缩到最小后对其右键取消勾选“设置可变大小”，根据实际情况可能还需要把间距的空隔宽度设为非零值，然后将这两个间距拖到 Present Windows Button 两边，这能令 Present Windows Button 两边不会显得拥挤，从而变得美观。&lt;/p>
&lt;h2 id="其它">其它&lt;/h2>
&lt;p>我知道存在 &lt;a class="link" href="https://store.kde.org/p/1167558/" target="_blank" rel="noopener"
>Winux10&lt;/a> 之类的图标主题可以将默认的图标替换为 win10 图标，但我经过尝试后发现其覆盖不全面，用以截图假装自己在使用 win10 是可以的，但日常使用会感到违和，所以还是推荐使用默认的图标主题。还有一个细节，那就是右下角的时钟，想让它像 win10 那样双栏显示日期和时间并不难：在底部栏空白处右键单击，选择“编辑面板”，编辑“面板高度”的值，稍微调高一些后，右键单击时钟，选择“配置数字时钟”，勾选“显示日期”，并将时间显示改为24小时制。&lt;/p>
&lt;h1 id="样式大改">样式大改&lt;/h1>
&lt;h2 id="桌面整体样式">桌面整体样式&lt;/h2>
&lt;p>仅仅只是桌面布局接近 win10 是不够的，还有相当一部分的桌面细节可以继续改进。这一部分主要是对桌面面板的图标以及挂件的样式进行修改，基于 &lt;a class="link" href="https://github.com/vinceliuice/Fluent-kde" target="_blank" rel="noopener"
>Fluent-kde&lt;/a> 这一项目来实现。Fluent-kde 包含了应用于各个方面的 Fluent 风格主题，由于我不打算折腾 Kvantum，所以仅使用其提供的 Plasma Desktop Themes。克隆 Fluent-kde 到本地后，进入项目目录并运行：&lt;/p>
&lt;pre>&lt;code>cp -r ./plasma/desktoptheme/* ~/.local/share/plasma/desktoptheme
&lt;/code>&lt;/pre>
&lt;p>然后就可以在系统设置中的“外观”-&amp;gt;“Plasma 视觉风格”中找到新增加的几个主题了，选择自己喜欢的 Fluent 风格主题并点击“应用”即可。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/KDE_to_Windows10/set_plasma_desktop_themes.png"
width="1465"
height="1024"
loading="lazy"
alt="设置 Plasma 视觉风格"
class="gallery-image"
data-flex-grow="143"
data-flex-basis="343px"
>&lt;/p>
&lt;h2 id="应用程序内部风格">应用程序内部风格&lt;/h2>
&lt;p>经过上面的折腾后，桌面截图已经足够接近 win10 了，但一旦随便打开一个应用就会露馅，所以需要也让应用程序的风格向 win10 靠拢。首先我们需要安装 &lt;a class="link" href="https://github.com/Luwx/Lightly" target="_blank" rel="noopener"
>Lightly&lt;/a> 主题，该主题虽然并非完全向 Fluent 靠拢，但也足够现代。由于目前其并不在积极维护状态，所以仅在 AUR 上有 PKGBUILD，可以在终端输入指令安装（需要安装 Yay 这个 AUR 助手）：&lt;/p>
&lt;pre>&lt;code>yay -S lightly-git
&lt;/code>&lt;/pre>
&lt;p>在安装完成后重启系统，打开系统设置，在侧栏点击“外观”，再点击“应用程序风格”，选择“Lightly”并应用更改；此外为还建议点击那个笔状的图标调整这个主题，把透明度改为下图中的数值。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/KDE_to_Windows10/use_lightly.png"
width="1467"
height="1026"
loading="lazy"
alt="应用 Lightly 主题"
class="gallery-image"
data-flex-grow="142"
data-flex-basis="343px"
>&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/KDE_to_Windows10/set_lightly_transparency.png"
width="731"
height="649"
loading="lazy"
alt="设置 Lightly 透明度"
class="gallery-image"
data-flex-grow="112"
data-flex-basis="270px"
>&lt;/p>
&lt;p>完成上面的操作随便打开一个 Qt 应用（如 Dolphin）都会发现其风格变得与 win10 应用很像，但 GTK 应用（如我使用的 lollypop）依然死性不改，原因就在于 GTK 应用与 Qt 应用所采用的主题是不一样的，为此我们需要安装同一个作者出品的 &lt;a class="link" href="https://www.gnome-look.org/p/1574551" target="_blank" rel="noopener"
>Fluent round gtk theme&lt;/a>。打开该主题页面后选择并下载一个自己喜欢的 Fluent 主题，然后将其解压到 ~/.themes 下（如该路径不存在则自行创建），重回刚才设置应用程序风格的界面，点击“配置 GNOME/GTK 应用程序风格”，选择刚安装的主题并点击“应用”。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/KDE_to_Windows10/set_gtk_app_theme.png"
width="1465"
height="1025"
loading="lazy"
alt="设置 GTK 应用风格"
class="gallery-image"
data-flex-grow="142"
data-flex-basis="343px"
>&lt;/p>
&lt;p>此时可以看到 lollypop 的风格也向 win10 靠拢了。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/KDE_to_Windows10/lollypop.png"
width="1299"
height="957"
loading="lazy"
alt="lollypop"
class="gallery-image"
data-flex-grow="135"
data-flex-basis="325px"
>&lt;/p>
&lt;h2 id="窗口装饰">窗口装饰&lt;/h2>
&lt;p>KDE 的窗口装饰指的是打开的应用程序窗口的顶部部分（就是包含了最小化、最大化、关闭按钮的那一栏）。我在 Google 搜索如何让 KDE 变得像 win10 时发现了一个非常新的 KDE 主题 &lt;a class="link" href="https://github.com/fauzie811/Breeze10" target="_blank" rel="noopener"
>Breeze10&lt;/a>，从 Github 页面上的图片可以看出这个主题可以完美地将窗口装饰变为 win10 的风格。&lt;del>由于目前（2019年12月）还没人打包，所以需要按照其 Github 页面上的操作步骤进行编译安装&lt;/del>。AUR 上已有 PKGBUILD，所以我们可以在终端输入指令安装（需要 Yay）：&lt;/p>
&lt;pre>&lt;code>yay -S breeze10-kde-git
&lt;/code>&lt;/pre>
&lt;p>此外，我的&lt;a class="link" href="https://viflythink.com/Use_Vercel_and_OneDrive_to_setup_your_repo/" target="_blank" rel="noopener"
>个人源&lt;/a>里也有该软件包，可以&lt;a class="link" href="https://viflythink.com/service/#arch-%E8%BD%AF%E4%BB%B6%E6%BA%90" target="_blank" rel="noopener"
>添加我的 Arch 软件源&lt;/a>后安装：&lt;/p>
&lt;pre>&lt;code>pacman -S breeze10-kde-git
&lt;/code>&lt;/pre>
&lt;p>在安装完成后重启系统，打开系统设置，在侧栏点击“外观”，再点击“窗口装饰元素”，选择“Breeze10”并应用更改；此外还可以点击那个笔状的图标调整这个主题，例如把字体设置变大，完成后你的应用程序窗口会显得更为美观大方。最后，把“窗口边框大小”设为“无边框”。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/KDE_to_Windows10/set_breeze10.png"
width="1462"
height="1027"
loading="lazy"
alt="使用 Breeze10"
class="gallery-image"
data-flex-grow="142"
data-flex-basis="341px"
>&lt;/p>
&lt;h1 id="其它细节">其它细节&lt;/h1>
&lt;p>当你习惯性地用 ALT + TAB 键想要切换窗口时，就会发现在默认设置的情况下窗口列表将在左侧显示，我个人更喜欢 win10 或 Gnome 那样在切换窗口将列表显示在屏幕中间，为了做到这一点，打开系统设置，在侧栏点击“窗口管理”，然后点击“任务切换器”，在“可视化”处选择大图标，可看下图：&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/KDE_to_Windows10/set_task_switch.png"
width="1093"
height="754"
loading="lazy"
alt="设置任务切换器"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="347px"
>&lt;/p>
&lt;p>我并不喜欢每次点击关机按钮后都要进行确认，而是希望像 win10 那样直接关机，这也是稍微修改系统设置即可做到的事情，打开系统设置，在侧栏点击“开机和关机”，然后点击“桌面会话”，取消勾选“注销屏幕”一栏的“显示”。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>经过这么多的折腾后，我总算是大概了解 KDE 了，“你可以将 KDE 捏成任何形状”毕竟只是一句用来吹嘘的话，除非动手改源代码，否则可自定义的部分总是有极限的，例如，在完成上述改造后，我对图标任务管理器并不完全满意，因为其显示的程序图标还是偏大，导致图标之间的间距不足，无法模拟 win10 底部栏的美观大方的感觉，当然，还有其它地方的间距设置也不尽人意，这些都难以通过安装主题等手段进行改造。当然，我个人认为没必要为此下结论说开源项目都处于美工下线的状态，其实无论是 KDE，亦或是 Gnome，它们的整体外观水平已经是与 Windows、Mac 这些商业公司开发的系统持平了，Linux 用户同样能有不差的桌面体验，KDE 等桌面所欠缺的只是一些审美细节，由于我也不懂设计，这里就不多说了。如果有兴趣的话，还可以多翻翻系统设置里的选项，其中包含了大量与桌面相关的自定义选项，这已经提供了非常大的改造空间。最后，在新的一年里，祝各位折腾愉快。&lt;/p></description></item><item><title>从 Debian 迁移到 Arch Linux</title><link>https://viflythink.com/Try_Arch_Linux/</link><pubDate>Sun, 03 Nov 2019 14:34:27 +0800</pubDate><guid>https://viflythink.com/Try_Arch_Linux/</guid><description>&lt;img src="https://viflythink.com/Try_Arch_Linux/show.jpg" alt="Featured image of post 从 Debian 迁移到 Arch Linux" />&lt;p>在用了将近两年的 Debian 后，我打算尝试另一个与 Debian 存在较大差别的发行版，做了一番比较后（&lt;del>并没有&lt;/del>）选择了相比 Debian 激进许多（经常需要滚包）的 Arch Linux。其实我在刚开始使用 Debian 时便听说过 Arch Linux 了，这都要归功于活跃的&lt;a class="link" href="https://www.archlinuxcn.org/" target="_blank" rel="noopener"
> Arch Linux 中文社区&lt;/a>，里面的人整天忙着安利 Arch Linux（&lt;del>传教&lt;/del>），而且，&lt;a class="link" href="https://wiki.archlinux.org/index.php/Main_page_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29" target="_blank" rel="noopener"
> Arch Linux 的 Wiki &lt;/a>也是非常优秀的文档，我在 Debian 上遇到问题时也会参考 Arch Linux 的 Wiki，久而久之，便产生了尝试 Arch Linux 的想法，此外，对于现在的我而言，&lt;a class="link" href="https://wiki.archlinux.org/index.php/Arch_Linux_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#%E5%8E%9F%E5%88%99" target="_blank" rel="noopener"
>Arch Linux 的哲学&lt;/a>也非常有意思，其中提到：&lt;/p>
&lt;blockquote>
&lt;p>Arch 适用于乐于自己动手的用户，他们愿意花时间阅读文档，解决自己的问题。&lt;/p>
&lt;/blockquote>
&lt;p>这完全符合我想折腾 Linux 的想法！当然，我认为 Arch Linux 并不适合 Linux 新手，因为光是第一步的命令行安装系统（Arch Linux 官方没有提供图形化安装界面）恐怕就能劝退不少人了，不过对于接触过 Linux 的人，通过理解 Arch Linux 安装过程中所需要输入的指令的含义，能体会到一种完全掌握自己的系统的快感（&lt;del>误入邪教&lt;/del>）。总而言之，对于喜欢折腾的人来说，尝试 Arch Linux 是绝对不会后悔的决定。&lt;/p>
&lt;p>由于 Arch Linux 的激进策略，安装教程很容易过时，我也不打算费力不讨好地写具体的安装步骤了，本文主要分享我在 Arch Linux 下使用的软件，希望能安利更多人使用（提到的不少软件都是跨平台的，即使不使用 Arch Linux 也可使用这些软件）。先在这里说一下我挑选软件的原则：通用性是最重要的，无论在哪个平台上使用都具有近乎一致的体验，为此没有利用单个平台的特性也是可接受的；数据可无障碍导出与导入，尊重用户的选择自由；简单易用且具备可扩展性（例如可安装扩展增强功能），但我也不排斥“一次配置，终身受用”这样需要折腾的软件；当然，开源是最好的。能达到这些要求的软件实属少数派，我在下文仅仅推荐几个，有空再补充。&lt;/p>
&lt;h1 id="安装">安装&lt;/h1>
&lt;p>考虑到 Arch Linux 经常变动，所以最好的安装指南应该是官方的&lt;a class="link" href="https://wiki.archlinux.org/index.php/Installation_guide" target="_blank" rel="noopener"
> Installation Guide&lt;/a>，我另外也参考了两篇博文，一个是萌狼的&lt;a class="link" href="https://blog.yoitsu.moe/arch-linux/installing_arch_linux_for_complete_newbies.html" target="_blank" rel="noopener"
>给 GNU/Linux 萌新的 Arch Linux 安装指南 rev.B&lt;/a>，&lt;del>另一个是&lt;a class="link" href="https://www.viseator.com/2017/05/17/arch_install/" target="_blank" rel="noopener"
>以官方Wiki的方式安装ArchLinux&lt;/a>&lt;/del>（由于 2019 年 10 月 Arch Linux 将 base 包组替换为同名的元包，这篇教程已过时）。对于我这样存在多系统的情况，执行了 grub-mkconfig 后最好检查一下/boot/grub/grub.cfg 是否包括了所有的系统。 &lt;br>
有关于桌面环境的选择，鉴于之前总是看到各位大佬吹 Arch Linux 的 KDE 桌面的美观，而我一直在 Debian 下使用 Gnome，这回便决定尝试 KDE（&lt;del>其实是为了在出问题时更容易找到大佬求救&lt;/del>），在安装了 kde-applications 后，开始嫌弃如此多的用不上的应用了（说的就是教育与游戏分类下的那堆东西），所以花了点时间写了一个&lt;a class="link" href="https://gist.github.com/vifly/33d1a4f63b0b7319c6db9af9d3bdbdb0" target="_blank" rel="noopener"
>简单的 Python 脚本&lt;/a>删除这些软件（&lt;strong>需要 root 权限，使用需谨慎&lt;/strong>）。安装完成后重启进入桌面，我不得不表示默认的 KDE 桌面比 Gnome 漂亮多了，相比之下，Gnome 的塑料风格看着实在是让我难受。另外，KDE 全家桶之间的配合也令我十分满意，统一的设计风格，美观的特效，让我忍不住想吹爆 KDE 了。有一个值得一提的细节，在 KDE 下的鼠标单击等于其它桌面环境下的鼠标双击（例如在其它桌面环境下打开文件需要双击），一开始我并不习惯这种设置，觉得不便于选中单个文件，但用多了以后发现这种操作明显更轻松，因为平常使用鼠标时双击的频率比单击要高，而双击肯定比单击累，将双击替换为单击肯定可以减缓疲劳，对于需要选中单个文件的情况，右键也能满足需求，这又成了一个我喜欢 KDE 的原因。&lt;br>
除了桌面环境外，首先需要熟悉的还有 Arch Linux 的软件包管理器 Pacman，它的命令行参数与 apt 完全不一样，开始使用时经常需要查看其&lt;a class="link" href="https://wiki.archlinux.org/index.php/Pacman" target="_blank" rel="noopener"
> Wiki 页面&lt;/a>，值得一提的是，得益于&lt;a class="link" href="https://wiki.archlinux.org/index.php/Arch_User_Repository" target="_blank" rel="noopener"
> AUR(Arch User Repository) &lt;/a>的存在以及 Arch Linux 打包的低门槛，Arch Linux 拥有数量庞大的软件包，考虑到可能会使用 AUR 里的软件包，所以我安装了&lt;a class="link" href="https://github.com/Jguer/yay" target="_blank" rel="noopener"
> Yay &lt;/a>这个&lt;a class="link" href="https://wiki.archlinux.org/index.php/AUR_helpers" target="_blank" rel="noopener"
> AUR 助手&lt;/a>（Yay 完全兼容 Pacman 的命令行参数）帮我节省输入 makepkg 等指令的步骤，下文涉及到安装软件的指令既有可能使用 Pacman，也有可能使用 Yay。&lt;/p>
&lt;h1 id="中国大陆用户所需的东西">中国大陆用户所需的东西&lt;/h1>
&lt;h2 id="中文设置">中文设置&lt;/h2>
&lt;p>我直接根据&lt;a class="link" href="https://szclsya.me/zh-cn/posts/fonts/linux-config-guide/" target="_blank" rel="noopener"
> Linux 下的字体调校指南&lt;/a>一文进行调教，在这里我想说一下该博文中提到的“archlinuxcn required”，这意味着需要&lt;a class="link" href="https://www.archlinuxcn.org/archlinux-cn-repo-and-mirror/" target="_blank" rel="noopener"
>添加 archlinuxcn 源&lt;/a>，上面介绍已经提到了 Arch Linux 中文社区，而这个社区维护着一个非官方软件仓库，被称为 Arch Linux 中文社区仓库（archlinuxcn 源），该仓库包括了很多中文用户会用到的已编译好的软件包，而 AUR 提供的是 PKGBUILD 打包脚本（这就是为什么你可通过 AUR 安装不少明确禁止二次分发的闭源软件的原因，因为 AUR 分发的是打包脚本而不是软件本体），需要下载后进行编译打包安装，如果你懒得自己打包的话，建议添加 archlinuxcn 源。在配置完成中文字体的显示后，在 KDE 的系统设置中将语言设置为中文就行了。另外，强烈建议阅读官方的&lt;a class="link" href="https://wiki.archlinux.org/index.php/Arch_Linux_%E4%B8%AD%E6%96%87%E5%8C%96" target="_blank" rel="noopener"
> Arch Linux 中文化&lt;/a>页面。&lt;/p>
&lt;h2 id="翻墙">翻墙&lt;/h2>
&lt;p>折腾 Linux 总是会遇到各种问题，这种时候便需要 Google 了，让我们先解决使用无法使用 Google 的问题（此处使用 V2Ray 作为例子，在官方软件仓库有 V2Ray 的软件包真是太好了）：&lt;/p>
&lt;pre>&lt;code>yay -S v2ray
&lt;/code>&lt;/pre>
&lt;p>安装后修改/etc/v2ray/config.json 的配置，然后：&lt;/p>
&lt;pre>&lt;code>sudo systemctl enable v2ray.service
sudo systemctl start v2ray.service
&lt;/code>&lt;/pre>
&lt;p>如果想让桌面应用走代理，可以在 KDE 的系统设置中点击“网络”中的设置，然后点击“代理”，选中“使用系统代理服务器配置”，填入对应的代理信息，示例如下：&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Try_Arch_Linux/set_kde_proxy.png"
width="1074"
height="736"
loading="lazy"
alt="KDE 设置系统代理"
class="gallery-image"
data-flex-grow="145"
data-flex-basis="350px"
>&lt;/p>
&lt;p>另外，V2Ray 支持 ShadowSocks 协议，可根据&lt;a class="link" href="https://www.v2ray.com/chapter_02/protocols/shadowsocks.html" target="_blank" rel="noopener"
> V2Ray 官方文档&lt;/a>写出配置文件，也可使用&lt;a class="link" href="https://www.veekxt.com/utils/v2ray_gen" target="_blank" rel="noopener"
>在线工具&lt;/a>生成；如果你使用 SSR 翻墙，AUR 中有&lt;a class="link" href="https://aur.archlinux.org/packages/electron-ssr/" target="_blank" rel="noopener"
> electron-ssr&lt;/a>，也有&lt;a class="link" href="https://aur.archlinux.org/packages/shadowsocksr/" target="_blank" rel="noopener"
> shadowsocksr&lt;/a>，但需要注意的是 electron-ssr 无法在 KDE 下自动设置代理（它使用了 gsetting 设置系统代理，不支持 KDE）。总之，安装好翻墙软件后终于能在电脑上使用 Google 查问题了。&lt;/p>
&lt;h1 id="终端模拟器与-shell">终端模拟器与 Shell&lt;/h1>
&lt;p>既然在 Linux 下，那么肯定免不了与终端打交道，既然如此，我们就需要一个美观、实用的终端（模拟器）。要说美观的话，KDE 自带的 Konsole 已经足够漂亮了，透明背景这一点让一直使用 Gnome Terminal 的我感到非常舒服，只需要稍微调整一下，就可以做到&lt;a class="link" href="https://kirikira.moe/post/28/#3" target="_blank" rel="noopener"
> kiri 大佬这样的效果&lt;/a>，让自己一整天都保持心情愉悦。不过在实用性方面我开始时遇到了一点问题，Konsole 使用的 Shell 是 Bash，而 Arch Linux 本身的 Bash 并没有自动补全配置，想要自动补全的话需要安装 bash-completion：&lt;/p>
&lt;pre>&lt;code>sudo pacman -S bash-completion
&lt;/code>&lt;/pre>
&lt;p>想要更高级的 Shell 体验的话（不知道终端模拟器与 Shell 有什么区别？请看&lt;a class="link" href="https://www.ihewro.com/archives/933/" target="_blank" rel="noopener"
>这&lt;/a>），也可以安装 zsh 加 oh-my-zsh 这样一整套的懒人包（或者自己配置 zsh？），只不过这里有一个小坑，在 AUR 中的 oh-my-zsh-git 并不会在 home 目录下生成 .zshrc，查找后发现在 /usr/share/oh-my-zsh 下有 zshrc 文件，我直接复制到 home 目录了，这里贴出安装懒人包的操作命令（将 username 改为你的用户名）：&lt;/p>
&lt;pre>&lt;code>yay -S zsh
sudo chsh -s /bin/zsh username
yay -S oh-my-zsh-git
cp /usr/share/oh-my-zsh/zshrc ~/.zshrc
&lt;/code>&lt;/pre>
&lt;p>更新：博主已经放弃启动速度慢的 oh-my-zsh，转向 Zinit 这个神器的怀抱了，另外，2021 年 11 月 Zinit 的原作者删除代码库，目前由 zdharma-continuum 组织接手进行维护，请注意 URL 的变化。Zinit 不仅轻松可以使用 oh-my-zsh 的各种插件，还拥有 Turbo mode 这个大幅减少插件加载时间的大杀器。如果你心动的话，请看&lt;a class="link" href="https://www.aloxaf.com/2019/11/zplugin_tutorial/" target="_blank" rel="noopener"
>加速你的 zsh —— 最强 zsh 插件管理器 zplugin/zinit 教程&lt;/a>一文。仅仅是照抄文末的示例配置，我也在保留 oh-my-zsh 体验的前提下感受到了起飞的加载速度，所以请无视上面的 oh-my-zsh，使用以下指令体验顺滑如丝的 Zinit（这里用了配置难度低的 proxychains-ng 翻墙下载 GitHub 片段，也可使用其它手段）：&lt;/p>
&lt;pre>&lt;code>yay -S zsh proxychains-ng
git clone https://github.com/zdharma-continuum/zinit.git ~/.zinit/bin
# 在 .zshrc 中添加 source ~/.zinit/bin/zinit.zsh 以及其它配置，可参考我的配置
nano .zshrc
# 配置 proxychains-ng，在最后一行添加类似 socks5 127.0.0.1 1080 的内容即可，自行谷歌了解配置
sudo nano /etc/proxychains.conf
# 启动 zsh，由于 .zshrc 已加载 Zinit，所以 zsh 首次启动时会自行下载 GitHub 上的片段
proxychains zsh
# 下载片段完成后退出执行这条指令更改默认 Shell，重启后见效果
sudo chsh -s /bin/zsh username
&lt;/code>&lt;/pre>
&lt;p>你可以在&lt;a class="link" href="https://github.com/vifly/dotfiles/blob/master/zsh/.zshrc" target="_blank" rel="noopener"
> GitHub &lt;/a>查看我的 zsh 配置，不过请记得根据自己的需求进行修改。&lt;/p>
&lt;h1 id="输入法">输入法&lt;/h1>
&lt;p>前面搞定了中文字体的显示，但是还没解决输入中文这个问题，在这里我选择了与使用 Debian 时同样的方案：基于 Fcitx 框架的 Rime 输入法。先贴一波安装指令（其它基于 Fcitx 框架的输入法请看&lt;a class="link" href="https://wiki.archlinux.org/index.php/Fcitx" target="_blank" rel="noopener"
> Wiki 页面&lt;/a>）：&lt;/p>
&lt;pre>&lt;code>sudo pacman -S fcitx fcitx-im fcitx-rime
&lt;/code>&lt;/pre>
&lt;p>为了确保能输入中文，修改一下/etc/profile，在开头加上：&lt;/p>
&lt;pre>&lt;code>export XMODIFIERS=&amp;quot;@im=fcitx&amp;quot;
export GTK_IM_MODULE=&amp;quot;fcitx&amp;quot;
export QT_IM_MODULE=&amp;quot;fcitx&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>另外，需要更改一下输入法配置，操作步骤是右键点击托盘中的输入法图标，选择“配置”，修改后的配置如下图所示（按 Shift 键可切换中英文）：&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Try_Arch_Linux/set_fcitx_1.png"
width="683"
height="820"
loading="lazy"
alt="输入法配置图1"
class="gallery-image"
data-flex-grow="83"
data-flex-basis="199px"
>&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Try_Arch_Linux/set_fcitx_2.png"
width="681"
height="816"
loading="lazy"
alt="输入法配置图2"
class="gallery-image"
data-flex-grow="83"
data-flex-basis="200px"
>&lt;/p>
&lt;p>最后，将我已经在 Debian 上调校好的 Rime 输入法配置文件拷贝过来（调校 Rime 的教程太多了，这里懒得贴了～），就能畅快地输入中文了。&lt;/p>
&lt;h1 id="多媒体">多媒体&lt;/h1>
&lt;p>这里选择在 Debian 上非常熟悉的 MPV 和 Rhythmbox 作为视频和音频播放器，之所以选择 MPV 是因为我已经有了一套&lt;a class="link" href="https://github.com/vifly/dotfiles/blob/master/mpv/.config/mpv/mpv.conf" target="_blank" rel="noopener"
>配置方案&lt;/a>，没必要选择其它播放器了，如果你还没使用过 MPV，那么&lt;a class="link" href="https://vcb-s.com/archives/7594/comment-page-1" target="_blank" rel="noopener"
>这里&lt;/a>有一篇相当不错的配置教程。而 Rhythmbox 支持不少插件，例如，在 KDE 桌面下，Rhythmbox 无法在关闭窗口时隐藏到托盘继续播放，可以通过安装 rhythmbox-tray-icon 插件解决：&lt;/p>
&lt;pre>&lt;code>yay -S rhythmbox-tray-icon
&lt;/code>&lt;/pre>
&lt;p>安装好插件后记得点击 Rhythmbox 右上角的设置按钮-&amp;gt;“插件”，在弹出的窗口中勾选刚安装的插件以激活插件效果，如下图：&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Try_Arch_Linux/rhythmbox_plugin.png"
width="778"
height="598"
loading="lazy"
alt="Rhythmbox 插件"
class="gallery-image"
data-flex-grow="130"
data-flex-basis="312px"
>&lt;/p>
&lt;p>除此以外，我还推荐 rhythmbox-equalizer 插件，安装后可调整 EQ。&lt;/p>
&lt;h1 id="生产力">生产力&lt;/h1>
&lt;p>属于生产力的工具有很多，我在这里只选择分享几个比较重要的工具。如果平常使用的生产力工具没有 Linux 客户端，或许可用网页版代替客户端（连网页版都没有的话，折腾下 wine 或放弃在 Linux 下使用吧）。&lt;/p>
&lt;h2 id="浏览器">浏览器&lt;/h2>
&lt;p>都说程序猿是面向 Google 编程的，既然如此，怎能缺少一个趁手的浏览器用于查资料呢。直接安装我在 Debian 上一直在使用的 Firefox 与 Chromium（Google Chrome 的开源部分）：&lt;/p>
&lt;pre>&lt;code>yay -S firefox-i18n-zh-cn chromium
&lt;/code>&lt;/pre>
&lt;p>这两个浏览器都有云同步机制，可直接将在其它平台上的浏览器资料同步过来，不想使用云同步的话，也可以手动复制用户资料以进行数据备份和迁移，Chromium 的用户资料在~/.config/chromium/Default/，浏览器扩展及其数据存放在这个目录下带有“Extensions”的子目录中；Firefox 有些不同，它轻松支持多个用户配置，你可以打开&lt;a class="link" href="about:profiles" > about:profiles &lt;/a>页面查看用户配置文件路径，显示“正在使用此配置文件，因而不能删除。”的就是当前的用户配置文件。 &lt;br>
对于我来说，选择这两个浏览器的一个重要原因就是可以安装扩展改善各种功能，例如禁用 JS 的 NoScript/ScriptSafe，拦截广告的 uBlock，为网页注入实用 JS 的 Greasemonkey，对于 Firefox 用户，还可参考编程随想的&lt;a class="link" href="https://program-think.blogspot.com/2016/10/custom-firefox-theme-without-extension.html" target="_blank" rel="noopener"
>无需任何插件或扩展，定制 Firefox 外观&lt;/a>和&lt;a class="link" href="https://program-think.blogspot.com/2019/07/Customize-Firefox.html" target="_blank" rel="noopener"
>扫盲 Firefox 定制——从“user.js”到“omni.ja”&lt;/a>进行更高级的定制。另外，从安全补丁的及时性这一角度来说，我也更推荐这两个浏览器，而不是基于这两者的衍生版。&lt;/p>
&lt;h2 id="代码编辑器与ide">代码编辑器与IDE&lt;/h2>
&lt;p>要问对程序猿而言最重要的生产力工具是什么，回答肯定是代码编辑器或 IDE。目前在 Linux 下我喜欢的编辑器就是 Visual Studio Code（简称 VS Code）了，虽然这是微软出品的（别跟 VS 搞混了，两者之间的差别非常大），不过用了以后还是要说一句“真香！”。它可以胜任多种需求，常见的 Python、C/C++等完全不在话下，也可以用作 Markdown 写作，像本文就是在 VS Code 下完成的，当然，值得一提的还有美观的界面，开箱即用的设置，这都令它在短时间内打动了我，再配合各种扩展，带来的是十分舒适的体验。对于 VS Code，我目前推荐 TabNine 以及 Markdown Preview Enhanced 这两个扩展，前者带来优秀的主流编程语言自动补全，后者带来更高级的 Markdown 预览体验（例如查看 LaTex）。&lt;/p>
&lt;p>&lt;img src="https://viflythink.com/Try_Arch_Linux/vs_code.png"
width="1920"
height="1043"
loading="lazy"
alt="VS Code 图"
class="gallery-image"
data-flex-grow="184"
data-flex-basis="441px"
>&lt;/p>
&lt;p>如果需要一个 IDE 的话，我推荐由 JetBrains 出品的 IDE，应该有不少人用过它家的 PyCharm 了，除此以外，Clion(C/C++)与 IntelliJ IDEA(Java)也是非常优秀的 IDE，至少在目前来说，Clion 对 Cmake 项目的支持可比 VS 好多了。另外，配合 Github 的学生认证可以白嫖 JetBrains 的产品，在此强烈推荐学生党尝试一下 Clion。&lt;/p>
&lt;h2 id="笔记">笔记&lt;/h2>
&lt;p>作为一个程序猿，总是会有记录笔记的需求，我目前有相当一部分的笔记资料储存在 EverNote 这个云笔记上，而它并没有 Linux 官方客户端，不过，得益于它的开放 API，早就有开发者做了一个在 Linux 下的客户端：NixNote（原名 Nevernote），Arch Linux 官方仓库有这个软件包：&lt;/p>
&lt;pre>&lt;code>sudo pacman -S nixnote2
&lt;/code>&lt;/pre>
&lt;p>&lt;del>只不过我遇到了在已设置应用程序使用语言为中文的情况下，菜单依然为英文的问题，Google 后找到一篇&lt;a class="link" href="https://blue-leaf81.net/archives/nixnote-translate-jp/" target="_blank" rel="noopener"
>让 NixNote 显示日语的教程&lt;/a>，受到这篇教程的启发，我查看了一下/usr/share/nixnote2/translations/目录，发现其中只有 nixnote2_cs_CZ.qm 文件，看来想要让菜单显示中文，就必须在这个目录下添加中文翻译。具体来说，先前往 GitHub 仓库下载&lt;a class="link" href="https://github.com/baumgarr/nixnote2/blob/master/translations/nixnote2_zh_CN.ts" target="_blank" rel="noopener"
>中文翻译源文件&lt;/a>，接着使用 Qt Linguist 打开下载回来的文件，然后点击左上角“File”-&amp;gt;&amp;ldquo;Release As&amp;quot;导出到/usr/share/nixnote2/translations/nixnote2_zh_CN.qm。重启 NixNote 便可以看到中文菜单了&lt;/del>。更新：2020年5月的更新已带上中文翻译，无需再按上面折腾。 &lt;br>
当然，EverNote 在 Linux 下还有&lt;a class="link" href="https://itsfoss.com/evernote-on-linux/" target="_blank" rel="noopener"
>几个非官方客户端&lt;/a>，我选择 NixNote 的原因在于它是使用 C++ QT 开发的，而不是类似于&lt;a class="link" href="https://github.com/klauscfhq/tusk" target="_blank" rel="noopener"
> Tusk &lt;/a>等使用前端技术开发的套壳 Web 应用，但对于 EverNote 的高级用户，我建议使用 EverNote 的网页版，而不是使用 NixNote，因为网页版的编辑功能比 NixNote 更优秀。&lt;/p>
&lt;h2 id="虚拟机">虚拟机&lt;/h2>
&lt;p>我有时候会有使用虚拟机运行 Windows 或其它 Linux 发行版的需求，这个时候就需要用到虚拟机了，VirtualBox 是一个操作简单且免费开源的虚拟机软件，根据&lt;a class="link" href="https://wiki.archlinux.org/index.php/VirtualBox" target="_blank" rel="noopener"
> Wiki 页面&lt;/a>进行安装（安装时会要求选择内核模块，没有更换默认内核的话，选择 virtualbox-host-modules-arch，不然选择 virtualbox-host-dkms）：&lt;/p>
&lt;pre>&lt;code>yay -S virtualbox virtualbox-ext-oracle virtualbox-guest-iso
&lt;/code>&lt;/pre>
&lt;p>假如你没有用过 VirtualBox，那么这里提醒一句，拖放文件和共享粘贴板等功能需要在运行中的虚拟机窗口上方点击“设备”-&amp;gt;“安装增强功能”才可使用。&lt;/p>
&lt;h1 id="后记">后记&lt;/h1>
&lt;p>得益于我对软件的通用性的要求，可以说是无痛从 Debian 迁移到了 Arch Linux，不少软件只需简单地复制粘贴配置文件即可（前提是已经有配置文件了），而且 Arch Linux 的系统安装过程也并不像我之前想象的那样复杂。折腾完这堆东西后最大的感触就是之前折腾积累的东西（如相关知识与配置）并没有浪费，若是没有相关的积累，面对安装 Arch Linux 以及安装完成后做什么这些问题恐怕会一头雾水，浪费不少时间，从节约时间的角度来说，编程随想所说的&lt;a class="link" href="https://program-think.blogspot.com/2013/10/personal-it-infrastructure.html" target="_blank" rel="noopener"
>重视个人 IT 基础设施的改善&lt;/a>是很有道理的。总之，安装好 Arch Linux 的我就像是一个刚得到新玩具的小孩子，正迫不及待地想要探索这个新玩具的有趣之处，更多有趣的软件留待日后补充好了。&lt;/p></description></item></channel></rss>